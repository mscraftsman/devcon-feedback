// generated by gocipe; DO NOT EDIT

package admin

import (
	"database/sql"
	"fmt"
	"strings"

	"github.com/pkg/errors"
	"golang.org/x/net/context"

	"github.com/mscraftsman/devcon-feedback/auth"
	"github.com/mscraftsman/devcon-feedback/models"
)

const (
	// StatusDraft says status is 'draft'
	StatusDraft = "draft"
	// StatusSaved says status is 'saved'
	StatusSaved = "saved"
	// StatusUnpublished says status is 'unpublished'
	StatusUnpublished = "unpublished"
	// StatusPublished says status is 'published'
	StatusPublished = "published"
)

var (
	// ErrorInvalidOperation indicates an error for an invalid operation
	ErrorInvalidOperation = errors.New("invalid filter operation specified")
	// ErrorRequestEmpty indicates an error when empty request is received
	ErrorRequestEmpty = errors.New("request object is malformed")
	// ErrorInvalidUploadField indicates an error for an unknown upload field
	ErrorInvalidUploadField = errors.New("invalid upload field")
	// ErrorInvalidStatus indicates an invalid status has been submitted
	ErrorInvalidStatus = errors.New("invalid status")

	_guardian auth.Guardian
)

// SetGuardian sets a custom guardian for admin service
// if guardian is nil, a dummyGuardian is used
func SetGuardian(guardian auth.Guardian) {
	if guardian == nil {
		_guardian = auth.DummyGuard
	} else {
		_guardian = guardian
	}
}

// Service represents Admin service implementation
type Service struct{}

// [BEGIN] Feedback

// CreateFeedback allows creation of entity of type Feedback
func (s Service) CreateFeedback(ctx context.Context, req *CreateFeedbackRequest) (*CreateFeedbackResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  CreateFeedbackResponse
		stop bool
	)

	if req == nil {
		return &res, ErrorRequestEmpty
	}

	if req.Feedback == nil {
		res.Feedback = new(models.Feedback)
	} else {
		res.Feedback = req.Feedback
		res.Feedback.ID = ""
	}

	passport, err := _guardian.GetPassport(req.GetKey())
	if err != nil {
		return &res, errors.WithStack(err)
	}

	if hasPerm := passport.HasPermission(PermCreateFeedback); !hasPerm {
		return &res, errors.WithStack(fmt.Errorf("Permission denied"))
	}

	res.Feedback.UserID = passport.GetID()

	switch res.Feedback.Status {
	case StatusDraft, StatusSaved, StatusUnpublished, StatusPublished:
		//all good
	default:
		res.Feedback.Status = StatusDraft
	}

	tx, err = models.StartTransaction(ctx)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	defer tx.Rollback()

	stop, err = s.feedbackPreCreate(ctx, tx, req, &res, passport, err)
	if stop {
		return &res, nil
	}
	if err != nil {
		return &res, errors.WithStack(err)
	}

	err = models.FeedbackRepo.Save(ctx, res.Feedback, tx, true)

	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.feedbackPostCreate(ctx, req, &res, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, errors.WithStack(err)
}

// GetFeedback allows getting a single entity of type Feedback
func (s Service) GetFeedback(ctx context.Context, req *GetRequest) (*GetFeedbackResponse, error) {
	var (
		res  GetFeedbackResponse
		err  error
		stop bool
	)

	if req == nil || req.ID == "" {
		return &res, ErrorRequestEmpty
	}

	stop, err = s.feedbackPreRead(ctx, req, &res)
	if stop {
		return &res, nil
	}

	res.Feedback, err = models.FeedbackRepo.GetWithRel(ctx, req.ID)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	passport, err := _guardian.GetPassport(req.GetKey())
	if err != nil {
		return &res, errors.WithStack(err)
	}

	var permission string
	isOwned := res.Feedback.UserID == passport.GetID()
	if isOwned {
		permission = PermEditFeedback
	} else {
		permission = PermEditFeedbackAny
	}

	if hasPerm := passport.HasPermission(permission); !hasPerm {
		return &res, errors.WithStack(fmt.Errorf("Permission denied"))
	}

	stop, err = s.feedbackPostRead(ctx, req, &res, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// ListFeedbacks allows listing all entity of type Feedback
func (s Service) ListFeedbacks(ctx context.Context, req *ListRequest) (*ListFeedbacksResponse, error) {
	var (
		res     ListFeedbacksResponse
		err     error
		stop    bool
		filters []*models.Filter
	)

	if req == nil {
		return &res, ErrorRequestEmpty
	}

	stop, err = s.feedbackPreList(ctx, req, &res)
	if stop {
		return &res, nil
	}

	if req.ListOpts == nil {
		req.ListOpts = &models.ListOpts{Offset: models.NoOffset, Limit: models.NoLimit}
	}

	if req.Filters != nil {
		for i := range req.Filters {
			switch req.Filters[i].Field {

			case "id", "status", "user_id", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id":
				if f, err := NewStringFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			case "created_at":
				if f, err := NewDateFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			}
		}
	}

	res.Feedbacks, err = models.FeedbackRepo.List(ctx, req.ListOpts, filters...)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.feedbackPostList(ctx, req, &res, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// CountFeedbacks allows counting of listing all entity of type Feedback
func (s Service) CountFeedbacks(ctx context.Context, req *ListRequest) (*CountResponse, error) {
	var (
		res     CountResponse
		err     error
		filters []*models.Filter
	)

	if req.Filters != nil {
		for i := range req.Filters {
			switch req.Filters[i].Field {

			case "id", "status", "user_id", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id":
				if f, err := NewStringFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			case "created_at":
				if f, err := NewDateFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			}
		}
	}

	res.Count, err = models.FeedbackRepo.Count(ctx, req.ListOpts, filters...)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	return &res, nil
}

// UpdateFeedback allows updating one entity of type Feedback
func (s Service) UpdateFeedback(ctx context.Context, req *UpdateFeedbackRequest) (*UpdateFeedbackResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  UpdateFeedbackResponse
		stop bool
	)

	if req == nil || req.Feedback == nil {
		return &res, ErrorRequestEmpty
	}

	passport, err := _guardian.GetPassport(req.GetKey())
	if err != nil {
		return &res, errors.WithStack(err)
	}

	var permission string
	isOwned := req.Feedback.UserID == passport.GetID()
	if isOwned {
		permission = PermEditFeedback
	} else {
		permission = PermEditFeedbackAny
	}

	if hasPerm := passport.HasPermission(permission); !hasPerm {
		return &res, errors.WithStack(fmt.Errorf("Permission denied"))
	}

	// existing records in DB
	existing, err := models.FeedbackRepo.Get(ctx, req.Feedback.ID)
	if err != nil {
		stop, err = s.feedbackPreUpdate(ctx, tx, req, &res, *existing, passport, err)
		if stop {
			return &res, nil
		}

		return &res, errors.WithStack(err)
	}

	switch req.Feedback.Status {
	case StatusDraft, StatusSaved, StatusUnpublished, StatusPublished:
		//all good
	default:
		return &res, ErrorInvalidStatus
	}

	res.Feedback = req.Feedback

	tx, err = models.StartTransaction(ctx)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	defer tx.Rollback()

	stop, err = s.feedbackPreUpdate(ctx, tx, req, &res, *existing, passport, err)
	if stop {
		return &res, nil
	}
	if err != nil {
		return &res, errors.WithStack(err)
	}

	err = models.FeedbackRepo.SaveWithRel(ctx, res.Feedback, tx, true)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.feedbackPostUpdate(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// DeleteFeedback allows deleting an entity of type Feedback
func (s Service) DeleteFeedback(ctx context.Context, req *DeleteRequest) (*DeleteResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  DeleteResponse
		stop bool
	)

	if req == nil || req.ID == "" {
		return &res, ErrorRequestEmpty
	}

	// existing records in DB
	existing, err := models.FeedbackRepo.Get(ctx, req.ID)
	if err != nil {
		stop, err = s.feedbackPreDelete(ctx, tx, req, &res, *existing, err)
		if stop {
			return &res, nil
		}

		return &res, errors.WithStack(err)
	}

	tx, err = models.StartTransaction(ctx)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	defer tx.Rollback()

	stop, err = s.feedbackPreDelete(ctx, tx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	if err != nil {
		return &res, errors.WithStack(err)
	}

	err = models.FeedbackRepo.Delete(ctx, existing, tx, true)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.feedbackPostDelete(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// LookupFeedbacks lookup allows looking up an entity by its label for entity of type Feedback
func (s Service) LookupFeedbacks(ctx context.Context, req *LookupRequest) (*LookupResponse, error) {
	var (
		err error
		res LookupResponse
	)

	if req == nil {
		return &res, ErrorRequestEmpty
	}

	if req.ListOpts == nil {
		req.ListOpts = &models.ListOpts{Offset: models.NoOffset, Limit: 25}
	}

	filter := &models.Filter{Field: "id", FieldFunction: models.FilterFuncLower, Operation: "LIKE", Value: "%" + strings.ToLower(req.Term) + "%"}

	Feedbacks, err := models.FeedbackRepo.List(ctx, req.ListOpts, filter)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	for _, e := range Feedbacks {
		res.Result = append(res.Result, &LookupResult{ID: e.ID, Label: e.ID, Status: e.Status})
	}

	return &res, err
}

// [END] Feedback

// [BEGIN] Visitor

// CreateVisitor allows creation of entity of type Visitor
func (s Service) CreateVisitor(ctx context.Context, req *CreateVisitorRequest) (*CreateVisitorResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  CreateVisitorResponse
		stop bool
	)

	if req == nil {
		return &res, ErrorRequestEmpty
	}

	if req.Visitor == nil {
		res.Visitor = new(models.Visitor)
	} else {
		res.Visitor = req.Visitor
		res.Visitor.ID = ""
	}

	passport, err := _guardian.GetPassport(req.GetKey())
	if err != nil {
		return &res, errors.WithStack(err)
	}

	if hasPerm := passport.HasPermission(PermCreateVisitor); !hasPerm {
		return &res, errors.WithStack(fmt.Errorf("Permission denied"))
	}

	res.Visitor.UserID = passport.GetID()

	switch res.Visitor.Status {
	case StatusDraft, StatusSaved, StatusUnpublished, StatusPublished:
		//all good
	default:
		res.Visitor.Status = StatusDraft
	}

	tx, err = models.StartTransaction(ctx)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	defer tx.Rollback()

	stop, err = s.visitorPreCreate(ctx, tx, req, &res, passport, err)
	if stop {
		return &res, nil
	}
	if err != nil {
		return &res, errors.WithStack(err)
	}

	err = models.VisitorRepo.Save(ctx, res.Visitor, tx, true)

	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.visitorPostCreate(ctx, req, &res, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, errors.WithStack(err)
}

// GetVisitor allows getting a single entity of type Visitor
func (s Service) GetVisitor(ctx context.Context, req *GetRequest) (*GetVisitorResponse, error) {
	var (
		res  GetVisitorResponse
		err  error
		stop bool
	)

	if req == nil || req.ID == "" {
		return &res, ErrorRequestEmpty
	}

	stop, err = s.visitorPreRead(ctx, req, &res)
	if stop {
		return &res, nil
	}

	res.Visitor, err = models.VisitorRepo.GetWithRel(ctx, req.ID)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	passport, err := _guardian.GetPassport(req.GetKey())
	if err != nil {
		return &res, errors.WithStack(err)
	}

	var permission string
	isOwned := res.Visitor.UserID == passport.GetID()
	if isOwned {
		permission = PermEditVisitor
	} else {
		permission = PermEditVisitorAny
	}

	if hasPerm := passport.HasPermission(permission); !hasPerm {
		return &res, errors.WithStack(fmt.Errorf("Permission denied"))
	}

	stop, err = s.visitorPostRead(ctx, req, &res, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// ListVisitors allows listing all entity of type Visitor
func (s Service) ListVisitors(ctx context.Context, req *ListRequest) (*ListVisitorsResponse, error) {
	var (
		res     ListVisitorsResponse
		err     error
		stop    bool
		filters []*models.Filter
	)

	if req == nil {
		return &res, ErrorRequestEmpty
	}

	stop, err = s.visitorPreList(ctx, req, &res)
	if stop {
		return &res, nil
	}

	if req.ListOpts == nil {
		req.ListOpts = &models.ListOpts{Offset: models.NoOffset, Limit: models.NoLimit}
	}

	if req.Filters != nil {
		for i := range req.Filters {
			switch req.Filters[i].Field {

			case "id", "status", "user_id", "name", "bookmark", "photo_link":
				if f, err := NewStringFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			case "created_at":
				if f, err := NewDateFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			}
		}
	}

	res.Visitors, err = models.VisitorRepo.List(ctx, req.ListOpts, filters...)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.visitorPostList(ctx, req, &res, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// CountVisitors allows counting of listing all entity of type Visitor
func (s Service) CountVisitors(ctx context.Context, req *ListRequest) (*CountResponse, error) {
	var (
		res     CountResponse
		err     error
		filters []*models.Filter
	)

	if req.Filters != nil {
		for i := range req.Filters {
			switch req.Filters[i].Field {

			case "id", "status", "user_id", "name", "bookmark", "photo_link":
				if f, err := NewStringFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			case "created_at":
				if f, err := NewDateFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			}
		}
	}

	res.Count, err = models.VisitorRepo.Count(ctx, req.ListOpts, filters...)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	return &res, nil
}

// UpdateVisitor allows updating one entity of type Visitor
func (s Service) UpdateVisitor(ctx context.Context, req *UpdateVisitorRequest) (*UpdateVisitorResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  UpdateVisitorResponse
		stop bool
	)

	if req == nil || req.Visitor == nil {
		return &res, ErrorRequestEmpty
	}

	passport, err := _guardian.GetPassport(req.GetKey())
	if err != nil {
		return &res, errors.WithStack(err)
	}

	var permission string
	isOwned := req.Visitor.UserID == passport.GetID()
	if isOwned {
		permission = PermEditVisitor
	} else {
		permission = PermEditVisitorAny
	}

	if hasPerm := passport.HasPermission(permission); !hasPerm {
		return &res, errors.WithStack(fmt.Errorf("Permission denied"))
	}

	// existing records in DB
	existing, err := models.VisitorRepo.Get(ctx, req.Visitor.ID)
	if err != nil {
		stop, err = s.visitorPreUpdate(ctx, tx, req, &res, *existing, passport, err)
		if stop {
			return &res, nil
		}

		return &res, errors.WithStack(err)
	}

	switch req.Visitor.Status {
	case StatusDraft, StatusSaved, StatusUnpublished, StatusPublished:
		//all good
	default:
		return &res, ErrorInvalidStatus
	}

	res.Visitor = req.Visitor

	tx, err = models.StartTransaction(ctx)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	defer tx.Rollback()

	stop, err = s.visitorPreUpdate(ctx, tx, req, &res, *existing, passport, err)
	if stop {
		return &res, nil
	}
	if err != nil {
		return &res, errors.WithStack(err)
	}

	err = models.VisitorRepo.SaveWithRel(ctx, res.Visitor, tx, true)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.visitorPostUpdate(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// DeleteVisitor allows deleting an entity of type Visitor
func (s Service) DeleteVisitor(ctx context.Context, req *DeleteRequest) (*DeleteResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  DeleteResponse
		stop bool
	)

	if req == nil || req.ID == "" {
		return &res, ErrorRequestEmpty
	}

	// existing records in DB
	existing, err := models.VisitorRepo.Get(ctx, req.ID)
	if err != nil {
		stop, err = s.visitorPreDelete(ctx, tx, req, &res, *existing, err)
		if stop {
			return &res, nil
		}

		return &res, errors.WithStack(err)
	}

	tx, err = models.StartTransaction(ctx)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	defer tx.Rollback()

	stop, err = s.visitorPreDelete(ctx, tx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	if err != nil {
		return &res, errors.WithStack(err)
	}

	err = models.VisitorRepo.Delete(ctx, existing, tx, true)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.visitorPostDelete(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// LookupVisitors lookup allows looking up an entity by its label for entity of type Visitor
func (s Service) LookupVisitors(ctx context.Context, req *LookupRequest) (*LookupResponse, error) {
	var (
		err error
		res LookupResponse
	)

	if req == nil {
		return &res, ErrorRequestEmpty
	}

	if req.ListOpts == nil {
		req.ListOpts = &models.ListOpts{Offset: models.NoOffset, Limit: 25}
	}

	filter := &models.Filter{Field: "name", FieldFunction: models.FilterFuncLower, Operation: "LIKE", Value: "%" + strings.ToLower(req.Term) + "%"}

	Visitors, err := models.VisitorRepo.List(ctx, req.ListOpts, filter)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	for _, e := range Visitors {
		res.Result = append(res.Result, &LookupResult{ID: e.ID, Label: e.Name, Status: e.Status})
	}

	return &res, err
}

// [END] Visitor

// [BEGIN] Rating

// CreateRating allows creation of entity of type Rating
func (s Service) CreateRating(ctx context.Context, req *CreateRatingRequest) (*CreateRatingResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  CreateRatingResponse
		stop bool
	)

	if req == nil {
		return &res, ErrorRequestEmpty
	}

	if req.Rating == nil {
		res.Rating = new(models.Rating)
	} else {
		res.Rating = req.Rating
		res.Rating.ID = ""
	}

	passport, err := _guardian.GetPassport(req.GetKey())
	if err != nil {
		return &res, errors.WithStack(err)
	}

	if hasPerm := passport.HasPermission(PermCreateRating); !hasPerm {
		return &res, errors.WithStack(fmt.Errorf("Permission denied"))
	}

	res.Rating.UserID = passport.GetID()

	switch res.Rating.Status {
	case StatusDraft, StatusSaved, StatusUnpublished, StatusPublished:
		//all good
	default:
		res.Rating.Status = StatusDraft
	}

	tx, err = models.StartTransaction(ctx)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	defer tx.Rollback()

	stop, err = s.ratingPreCreate(ctx, tx, req, &res, passport, err)
	if stop {
		return &res, nil
	}
	if err != nil {
		return &res, errors.WithStack(err)
	}

	err = models.RatingRepo.Save(ctx, res.Rating, tx, true)

	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.ratingPostCreate(ctx, req, &res, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, errors.WithStack(err)
}

// GetRating allows getting a single entity of type Rating
func (s Service) GetRating(ctx context.Context, req *GetRequest) (*GetRatingResponse, error) {
	var (
		res  GetRatingResponse
		err  error
		stop bool
	)

	if req == nil || req.ID == "" {
		return &res, ErrorRequestEmpty
	}

	stop, err = s.ratingPreRead(ctx, req, &res)
	if stop {
		return &res, nil
	}

	res.Rating, err = models.RatingRepo.GetWithRel(ctx, req.ID)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	passport, err := _guardian.GetPassport(req.GetKey())
	if err != nil {
		return &res, errors.WithStack(err)
	}

	var permission string
	isOwned := res.Rating.UserID == passport.GetID()
	if isOwned {
		permission = PermEditRating
	} else {
		permission = PermEditRatingAny
	}

	if hasPerm := passport.HasPermission(permission); !hasPerm {
		return &res, errors.WithStack(fmt.Errorf("Permission denied"))
	}

	stop, err = s.ratingPostRead(ctx, req, &res, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// ListRatings allows listing all entity of type Rating
func (s Service) ListRatings(ctx context.Context, req *ListRequest) (*ListRatingsResponse, error) {
	var (
		res     ListRatingsResponse
		err     error
		stop    bool
		filters []*models.Filter
	)

	if req == nil {
		return &res, ErrorRequestEmpty
	}

	stop, err = s.ratingPreList(ctx, req, &res)
	if stop {
		return &res, nil
	}

	if req.ListOpts == nil {
		req.ListOpts = &models.ListOpts{Offset: models.NoOffset, Limit: models.NoLimit}
	}

	if req.Filters != nil {
		for i := range req.Filters {
			switch req.Filters[i].Field {

			case "id", "status", "user_id", "rating_count", "reaction_summary":
				if f, err := NewStringFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			case "created_at", "updated_at":
				if f, err := NewDateFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			}
		}
	}

	res.Ratings, err = models.RatingRepo.List(ctx, req.ListOpts, filters...)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.ratingPostList(ctx, req, &res, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// CountRatings allows counting of listing all entity of type Rating
func (s Service) CountRatings(ctx context.Context, req *ListRequest) (*CountResponse, error) {
	var (
		res     CountResponse
		err     error
		filters []*models.Filter
	)

	if req.Filters != nil {
		for i := range req.Filters {
			switch req.Filters[i].Field {

			case "id", "status", "user_id", "rating_count", "reaction_summary":
				if f, err := NewStringFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			case "created_at", "updated_at":
				if f, err := NewDateFilter(req.Filters[i]); err == nil {
					filters = append(filters, f)
				} else {
					return &res, err
				}

			}
		}
	}

	res.Count, err = models.RatingRepo.Count(ctx, req.ListOpts, filters...)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	return &res, nil
}

// UpdateRating allows updating one entity of type Rating
func (s Service) UpdateRating(ctx context.Context, req *UpdateRatingRequest) (*UpdateRatingResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  UpdateRatingResponse
		stop bool
	)

	if req == nil || req.Rating == nil {
		return &res, ErrorRequestEmpty
	}

	passport, err := _guardian.GetPassport(req.GetKey())
	if err != nil {
		return &res, errors.WithStack(err)
	}

	var permission string
	isOwned := req.Rating.UserID == passport.GetID()
	if isOwned {
		permission = PermEditRating
	} else {
		permission = PermEditRatingAny
	}

	if hasPerm := passport.HasPermission(permission); !hasPerm {
		return &res, errors.WithStack(fmt.Errorf("Permission denied"))
	}

	// existing records in DB
	existing, err := models.RatingRepo.Get(ctx, req.Rating.ID)
	if err != nil {
		stop, err = s.ratingPreUpdate(ctx, tx, req, &res, *existing, passport, err)
		if stop {
			return &res, nil
		}

		return &res, errors.WithStack(err)
	}

	switch req.Rating.Status {
	case StatusDraft, StatusSaved, StatusUnpublished, StatusPublished:
		//all good
	default:
		return &res, ErrorInvalidStatus
	}

	res.Rating = req.Rating

	tx, err = models.StartTransaction(ctx)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	defer tx.Rollback()

	stop, err = s.ratingPreUpdate(ctx, tx, req, &res, *existing, passport, err)
	if stop {
		return &res, nil
	}
	if err != nil {
		return &res, errors.WithStack(err)
	}

	err = models.RatingRepo.SaveWithRel(ctx, res.Rating, tx, true)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.ratingPostUpdate(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// DeleteRating allows deleting an entity of type Rating
func (s Service) DeleteRating(ctx context.Context, req *DeleteRequest) (*DeleteResponse, error) {
	var (
		err  error
		tx   *sql.Tx
		res  DeleteResponse
		stop bool
	)

	if req == nil || req.ID == "" {
		return &res, ErrorRequestEmpty
	}

	// existing records in DB
	existing, err := models.RatingRepo.Get(ctx, req.ID)
	if err != nil {
		stop, err = s.ratingPreDelete(ctx, tx, req, &res, *existing, err)
		if stop {
			return &res, nil
		}

		return &res, errors.WithStack(err)
	}

	tx, err = models.StartTransaction(ctx)
	if err != nil {
		return &res, errors.WithStack(err)
	}
	defer tx.Rollback()

	stop, err = s.ratingPreDelete(ctx, tx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}
	if err != nil {
		return &res, errors.WithStack(err)
	}

	err = models.RatingRepo.Delete(ctx, existing, tx, true)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	stop, err = s.ratingPostDelete(ctx, req, &res, *existing, err)
	if stop {
		return &res, nil
	}

	if err != nil {
		return &res, errors.WithStack(err)
	}

	return &res, nil
}

// LookupRatings lookup allows looking up an entity by its label for entity of type Rating
func (s Service) LookupRatings(ctx context.Context, req *LookupRequest) (*LookupResponse, error) {
	var (
		err error
		res LookupResponse
	)

	if req == nil {
		return &res, ErrorRequestEmpty
	}

	if req.ListOpts == nil {
		req.ListOpts = &models.ListOpts{Offset: models.NoOffset, Limit: 25}
	}

	filter := &models.Filter{Field: "id", FieldFunction: models.FilterFuncLower, Operation: "LIKE", Value: "%" + strings.ToLower(req.Term) + "%"}

	Ratings, err := models.RatingRepo.List(ctx, req.ListOpts, filter)
	if err != nil {
		return &res, errors.WithStack(err)
	}

	for _, e := range Ratings {
		res.Result = append(res.Result, &LookupResult{ID: e.ID, Label: e.ID, Status: e.Status})
	}

	return &res, err
}

// [END] Rating
