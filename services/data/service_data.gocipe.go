// generated by gocipe; DO NOT EDIT

package data

import (
	context "context"

	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"

	"github.com/mscraftsman/devcon-feedback/models"
	"github.com/mscraftsman/devcon-feedback/models/moderrors"
)

const (
	// _statusPublished: status = 'published'
	_statusPublished = "published"
)

var (
	errIDNotProvided   = errors.New("ID not provided")
	errSlugNotProvided = errors.New("Slug not provided")
	errItemNotFound    = errors.New("item not found")
)

// getModified returns the last modified date from database, given a table name, a field to compare a given value against for matching.
// warning: unsafe against sql injection. table and field data must be validated before passed to this function.
func getModified(table, field, value string) (*timestamp.Timestamp, error) {
	ctx := context.Background()

	tx, err := models.StartTransaction(ctx)
	if err != nil {
		return nil, err
	}
	defer tx.Rollback()

	query := `SELECT "updated_at" FROM ` + table + ` WHERE "` + field + `" = $1`
	stmt, err := tx.PrepareContext(ctx, query)
	defer stmt.Close()
	if err != nil {
		return nil, err
	}

	rows, err := stmt.QueryContext(ctx, value)
	defer rows.Close()
	if err != nil {
		return nil, err
	}

	if rows.Next() {
		var modified timestamp.Timestamp
		err = rows.Scan(&modified)
		if err != nil {
			log.WithFields(log.Fields{"query": query, field: value, "error": err}).Error("service data: getModified scan error")
			return nil, err
		}

		return &modified, nil
	}

	return nil, errItemNotFound
}

// [BEGIN] Feedback

// GetFeedbackByID fetches published Feedback from DB by ID
func GetFeedbackByID(ctx context.Context, id string) (*models.Feedback, error) {
	var (
		entities []*models.Feedback
		err      error
	)

	log.WithFields(log.Fields{}).Debug("data::GetFeedbackByID() entered")

	entities, err = models.FeedbackRepo.List(
		ctx,
		&models.ListOpts{Offset: 0, Limit: 1, Sort: []*models.ListSortOpts{}},
		&models.Filter{Field: "id", Operation: "=", Value: id},
		&models.Filter{Field: "status", Operation: "=", Value: _statusPublished},
	)

	if err != nil {
		log.WithFields(log.Fields{"error": err}).Warn("FeedbackRepo.List() error in data::GetFeedbackByID()")
		return nil, errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entities": entities}).Debug("Result of FeedbackRepo.List() in data::GetFeedbackByID()")

	if len(entities) < 1 {
		return nil, moderrors.RecordNotFoundError
	}

	log.WithFields(log.Fields{}).Debug("data::GetFeedbackByID() DONE!")

	return entities[0], nil
}

// ListFeedbacks fetches a list of published Feedbacks from DB
func ListFeedbacks(ctx context.Context, listOpts *models.ListOpts) ([]*models.Feedback, error) {
	var (
		entities []*models.Feedback
		err      error
	)

	log.WithFields(log.Fields{}).Debug("data::ListFeedback() entered")

	entities, err = models.FeedbackRepo.ListWithRel(ctx, listOpts,
		&models.Filter{Field: "status", Operation: "=", Value: _statusPublished},
	)
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Warn("data::ListFeedback(): FeedbackRepo.ListWithRel() error")
		return nil, errors.WithStack(err)
	}

	log.WithFields(log.Fields{"entities": entities}).Debug("data::ListFeedback() DONE!")
	return entities, nil
}

// [END] Feedback

// [BEGIN] Visitor

// GetVisitorByID fetches published Visitor from DB by ID
func GetVisitorByID(ctx context.Context, id string) (*models.Visitor, error) {
	var (
		entities []*models.Visitor
		err      error
	)

	log.WithFields(log.Fields{}).Debug("data::GetVisitorByID() entered")

	entities, err = models.VisitorRepo.List(
		ctx,
		&models.ListOpts{Offset: 0, Limit: 1, Sort: []*models.ListSortOpts{}},
		&models.Filter{Field: "id", Operation: "=", Value: id},
		&models.Filter{Field: "status", Operation: "=", Value: _statusPublished},
	)

	if err != nil {
		log.WithFields(log.Fields{"error": err}).Warn("VisitorRepo.List() error in data::GetVisitorByID()")
		return nil, errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entities": entities}).Debug("Result of VisitorRepo.List() in data::GetVisitorByID()")

	if len(entities) < 1 {
		return nil, moderrors.RecordNotFoundError
	}

	log.WithFields(log.Fields{}).Debug("data::GetVisitorByID() DONE!")

	return entities[0], nil
}

// ListVisitors fetches a list of published Visitors from DB
func ListVisitors(ctx context.Context, listOpts *models.ListOpts) ([]*models.Visitor, error) {
	var (
		entities []*models.Visitor
		err      error
	)

	log.WithFields(log.Fields{}).Debug("data::ListVisitor() entered")

	entities, err = models.VisitorRepo.ListWithRel(ctx, listOpts,
		&models.Filter{Field: "status", Operation: "=", Value: _statusPublished},
	)
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Warn("data::ListVisitor(): VisitorRepo.ListWithRel() error")
		return nil, errors.WithStack(err)
	}

	log.WithFields(log.Fields{"entities": entities}).Debug("data::ListVisitor() DONE!")
	return entities, nil
}

// [END] Visitor

// [BEGIN] Rating

// GetRatingByID fetches published Rating from DB by ID
func GetRatingByID(ctx context.Context, id string) (*models.Rating, error) {
	var (
		entities []*models.Rating
		err      error
	)

	log.WithFields(log.Fields{}).Debug("data::GetRatingByID() entered")

	entities, err = models.RatingRepo.List(
		ctx,
		&models.ListOpts{Offset: 0, Limit: 1, Sort: []*models.ListSortOpts{}},
		&models.Filter{Field: "id", Operation: "=", Value: id},
		&models.Filter{Field: "status", Operation: "=", Value: _statusPublished},
	)

	if err != nil {
		log.WithFields(log.Fields{"error": err}).Warn("RatingRepo.List() error in data::GetRatingByID()")
		return nil, errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entities": entities}).Debug("Result of RatingRepo.List() in data::GetRatingByID()")

	if len(entities) < 1 {
		return nil, moderrors.RecordNotFoundError
	}

	log.WithFields(log.Fields{}).Debug("data::GetRatingByID() DONE!")

	return entities[0], nil
}

// ListRatings fetches a list of published Ratings from DB
func ListRatings(ctx context.Context, listOpts *models.ListOpts) ([]*models.Rating, error) {
	var (
		entities []*models.Rating
		err      error
	)

	log.WithFields(log.Fields{}).Debug("data::ListRating() entered")

	entities, err = models.RatingRepo.ListWithRel(ctx, listOpts,
		&models.Filter{Field: "status", Operation: "=", Value: _statusPublished},
	)
	if err != nil {
		log.WithFields(log.Fields{"error": err}).Warn("data::ListRating(): RatingRepo.ListWithRel() error")
		return nil, errors.WithStack(err)
	}

	log.WithFields(log.Fields{"entities": entities}).Debug("data::ListRating() DONE!")
	return entities, nil
}

// [END] Rating

// ------------------
// [Service Data] ---
// ------------------

// Service represents Data service implementation
type Service struct{}

// [BEGIN] Feedback

// GetFeedbackByID returns a single Feedback from database by primary key
func (s Service) GetFeedbackByID(ctx context.Context, req *GetByIDRequest) (*FeedbackResponse, error) {
	var (
		res FeedbackResponse
		err error
	)

	if req.GetID() == "" {
		return nil, errors.WithStack(errIDNotProvided)
	}

	res.Feedback, err = GetFeedbackByID(ctx, req.GetID())
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}

// ListFeedbacks allows listing all entity of type Feedback
func (s Service) ListFeedbacks(ctx context.Context, req *ListRequest) (*ListFeedbacksResponse, error) {
	var (
		res ListFeedbacksResponse
		err error
	)

	res.Feedbacks, err = ListFeedbacks(ctx, &models.ListOpts{Offset: req.ListOpts.GetOffset(), Limit: req.ListOpts.GetLimit()})
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}

// [END] Feedback

// [BEGIN] Visitor

// GetVisitorByID returns a single Visitor from database by primary key
func (s Service) GetVisitorByID(ctx context.Context, req *GetByIDRequest) (*VisitorResponse, error) {
	var (
		res VisitorResponse
		err error
	)

	if req.GetID() == "" {
		return nil, errors.WithStack(errIDNotProvided)
	}

	res.Visitor, err = GetVisitorByID(ctx, req.GetID())
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}

// ListVisitors allows listing all entity of type Visitor
func (s Service) ListVisitors(ctx context.Context, req *ListRequest) (*ListVisitorsResponse, error) {
	var (
		res ListVisitorsResponse
		err error
	)

	res.Visitors, err = ListVisitors(ctx, &models.ListOpts{Offset: req.ListOpts.GetOffset(), Limit: req.ListOpts.GetLimit()})
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}

// [END] Visitor

// [BEGIN] Rating

// GetRatingByID returns a single Rating from database by primary key
func (s Service) GetRatingByID(ctx context.Context, req *GetByIDRequest) (*RatingResponse, error) {
	var (
		res RatingResponse
		err error
	)

	if req.GetID() == "" {
		return nil, errors.WithStack(errIDNotProvided)
	}

	res.Rating, err = GetRatingByID(ctx, req.GetID())
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}

// GetModifiedRatingByID returns time of modification for entity by ID
func (s Service) GetModifiedRatingByID(ctx context.Context, req *GetByIDRequest) (*TimestampResponse, error) {
	var (
		res TimestampResponse
		err error
	)

	if req.GetID() == "" {
		return nil, errors.WithStack(errIDNotProvided)
	}

	res.ModifiedAt, err = getModified("ratings", "id", req.GetID())
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}

// ListRatings allows listing all entity of type Rating
func (s Service) ListRatings(ctx context.Context, req *ListRequest) (*ListRatingsResponse, error) {
	var (
		res ListRatingsResponse
		err error
	)

	res.Ratings, err = ListRatings(ctx, &models.ListOpts{Offset: req.ListOpts.GetOffset(), Limit: req.ListOpts.GetLimit()})
	if err != nil {
		return nil, errors.WithStack(err)
	}

	return &res, nil
}

// [END] Rating
