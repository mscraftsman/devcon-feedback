// generated by gocipe; DO NOT EDIT

package models

import (
	"context"
	"database/sql"
	"strconv"
	"strings"
	"time"

	"github.com/golang/protobuf/ptypes"
	"github.com/mscraftsman/devcon-feedback/models/moderrors"
	"github.com/mscraftsman/devcon-feedback/util"
	"github.com/pkg/errors"
	log "github.com/sirupsen/logrus"

	uuid "github.com/satori/go.uuid"
)

// [BEGIN] Feedback

// Insert performs an SQL insert for Feedback record and update instance with inserted id. Prefer using Save instead of Insert directly.
func (repo FeedbackRepositorium) Insert(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.Insert entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Feedback.Insert Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Insert context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Insert StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()
	entity.CreatedAt = ptypes.TimestampNow()
	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`INSERT INTO feedbacks ("id", "status", "user_id", "created_at", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO feedbacks ("id", "status", "user_id", "created_at", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`, "error": err}).Error("repo.Feedback.Insert query error")
		return errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.Insert query done")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Insert context error")
		return errors.WithStack(err)
	}

	entity.ID = uuid.NewV4().String()

	_, err = stmt.Exec(entity.ID, entity.Status, entity.UserID, createdat, entity.SessionID, entity.Reaction1, entity.Reaction2, entity.Reaction3, entity.Reaction4, entity.VisitorID)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Insert query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Insert context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Insert commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// InsertWithRel performs an SQL insert for Feedback record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.
func (repo FeedbackRepositorium) InsertWithRel(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error {
	var (
		id        string
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.InsertWithRel entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Feedback.InsertWithRel Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.InsertWithRel context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.InsertWithRel StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()
	entity.CreatedAt = ptypes.TimestampNow()
	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`INSERT INTO feedbacks ("id", "status", "user_id", "created_at", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO feedbacks ("id", "status", "user_id", "created_at", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)`, "error": err}).Error("repo.Feedback.InsertWithRel query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.InsertWithRel context error")
		return errors.WithStack(err)
	}
	idUUID := uuid.NewV4()
	id = idUUID.String()
	entity.ID = id

	_, err = stmt.Exec(&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.SessionID, &entity.Reaction1, &entity.Reaction2, &entity.Reaction3, &entity.Reaction4, &entity.VisitorID)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.InsertWithRel query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.InsertWithRel context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.InsertWithRel commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// Get returns a single Feedback from database by primary key
func (repo FeedbackRepositorium) Get(ctx context.Context, id string) (*Feedback, error) {
	var (
		rows   *sql.Rows
		err    error
		entity Feedback
	)

	log.WithFields(log.Fields{"id": id}).Debug("repo.Feedback.Get entered")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Info("repo.Feedback.Get context error")
		return nil, err
	}

	rows, err = repo.db.QueryContext(ctx, `SELECT t."id", t."status", t."user_id", t."created_at", t."session_id", t."reaction1", t."reaction2", t."reaction3", t."reaction4", t."visitor_id" FROM feedbacks t WHERE t."id" = $1 ORDER BY t."id" ASC`, id)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"id": id, "query": `SELECT t."id", t."status", t."user_id", t."created_at", t."session_id", t."reaction1", t."reaction2", t."reaction3", t."reaction4", t."visitor_id" FROM feedbacks t WHERE t."id" = $1 ORDER BY t."id" ASC`, "error": err}).Error("repo.Feedback.Get query error")
		return nil, err
	}
	log.WithFields(log.Fields{"id": id}).Debug("repo.Feedback.Get query done")
	if rows.Next() {
		log.WithFields(log.Fields{"id": id}).Debug("repo.Feedback.Get row found")
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"id": id, "error": err}).Info("repo.Feedback.Get context error")
			return nil, err
		}

		var createdat time.Time

		err = rows.Scan(&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.SessionID, &entity.Reaction1, &entity.Reaction2, &entity.Reaction3, &entity.Reaction4, &entity.VisitorID)
		if err != nil {
			log.WithFields(log.Fields{"id": id, "query": `SELECT t."id", t."status", t."user_id", t."created_at", t."session_id", t."reaction1", t."reaction2", t."reaction3", t."reaction4", t."visitor_id" FROM feedbacks t WHERE t."id" = $1 ORDER BY t."id" ASC`, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.SessionID, &entity.Reaction1, &entity.Reaction2, &entity.Reaction3, &entity.Reaction4, &entity.VisitorID", "error": err}).Error("repo.Feedback.Get scan error")
			return nil, err
		}

		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)

		log.WithFields(log.Fields{"id": id}).Debug("repo.Feedback.Get data scan done")
	} else {
		log.WithFields(log.Fields{"id": id}).Debug("repo.Feedback.Get data not found")
		return nil, moderrors.RecordNotFoundError
	}

	return &entity, nil
}

// GetWithRel returns a single Feedback from database by primary key; loads related entities
func (repo FeedbackRepositorium) GetWithRel(ctx context.Context, id string) (*Feedback, error) {
	log.WithFields(log.Fields{"id": id}).Debug("repo.Feedback.GetWithRel entered")
	entity, err := repo.Get(ctx, id)
	if err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Error("repo.Feedback.GetWithRel get entity error")
		return nil, err
	}
	log.WithFields(log.Fields{"id": id}).Debug("repo.Feedback.GetWithRel entity loaded")

	err = repo.LoadVisitor(ctx, entity)
	if err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Error("repo.Feedback.Get load related Visitor error")
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Info("repo.Feedback.Get context error")
		return nil, err
	}
	log.WithFields(log.Fields{"id": id}).Debug("repo.Feedback.GetWithRel related Visitor loaded")

	return entity, nil
}

// List returns a slice containing Feedback records
func (repo FeedbackRepositorium) List(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Feedback, error) {
	var (
		list     []*Feedback
		segments []string
		values   []interface{}
		err      error
		rows     *sql.Rows
		index    int = 0
	)

	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Feedback.List entered")
	query := `SELECT t."id", t."status", t."user_id", t."created_at", t."session_id", t."reaction1", t."reaction2", t."reaction3", t."reaction4", t."visitor_id" FROM feedbacks t`

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Feedback.List context error")
		return nil, err
	}

	for _, filter := range filters {
		switch filter.Field {
		default:
			continue
		case "id", "status", "user_id", "created_at", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id":
			//ok
		}

		if filter.Operation == "IN" || filter.Operation == "NOT IN" { //TODO SQL-dialect sensitive
			seg, val, err := QueryAddIN(segments, values, &index, `t."`+filter.Field+`"`, filter.Value, "NOT IN" == filter.Operation)
			if err != nil {
				log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Feedback.List QueryAddIN error")
				continue
			}
			segments = seg
			values = val
		} else {
			index++
			segments = append(segments, filter.ToQuerySegment(index))
			values = append(values, filter.Value)
		}
	}

	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}

	if opts != nil { //TODO SQL-dialect sensitive
		query += opts.SortOpts(func(field string) bool {
			switch field { //TODO SQL-dialect sensitive
			case "id", "status", "user_id", "created_at", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id":
				return true
			}

			return false
		})
	} else {
		query += ` ORDER BY t."created_at" ASC`
	}

	if opts != nil && opts.Offset > 0 { //TODO SQL-dialect sensitive
		query += " OFFSET " + strconv.FormatInt(opts.Offset, 10)
	}

	if opts != nil && opts.Limit > 0 { //TODO SQL-dialect sensitive
		query += " LIMIT " + strconv.FormatInt(opts.Limit, 10)
	}

	rows, err = repo.db.QueryContext(ctx, query, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "error": err}).Error("repo.Feedback.List query error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Feedback.List query done")

	for rows.Next() {
		log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Feedback.List row found")
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Feedback.List context error")
			return nil, err
		}

		var entity Feedback
		var createdat time.Time

		err = rows.Scan(&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.SessionID, &entity.Reaction1, &entity.Reaction2, &entity.Reaction3, &entity.Reaction4, &entity.VisitorID)
		if err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.SessionID, &entity.Reaction1, &entity.Reaction2, &entity.Reaction3, &entity.Reaction4, &entity.VisitorID", "error": err}).Error("repo.Feedback.List scan error")
			return nil, err
		}

		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)

		log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Feedback.List data scan done")
		list = append(list, &entity)

	}

	return list, nil
}

// Count returns a count of a query containing Feedback records
func (repo FeedbackRepositorium) Count(ctx context.Context, opts *ListOpts, filters ...*Filter) (int64, error) {
	var (
		segments []string
		values   []interface{}
		err      error
		rows     *sql.Rows
		index    int = 0
		count    int64
	)
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Feedback.Count entered")
	query := `SELECT COUNT(id) FROM feedbacks t`
	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Feedback.Count context error")
		return count, err
	}
	for _, filter := range filters {
		switch filter.Field {
		default:
			continue
		case "id", "status", "user_id", "created_at", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id":
			//ok
		}

		if filter.Operation == "IN" || filter.Operation == "NOT IN" {
			seg, val, err := QueryAddIN(segments, values, &index, filter.Field, filter.Value, "NOT IN" == filter.Operation)
			if err != nil {
				log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Feedback.Count QueryAddIN error")
				continue
			}
			segments = seg
			values = val
		} else {
			index++
			segments = append(segments, filter.Field+" "+filter.Operation+" $"+strconv.Itoa(index))
			values = append(values, filter.Value)
		}
	}
	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}
	rows, err = repo.db.QueryContext(ctx, query, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "error": err}).Error("repo.Feedback.Count query error")
		return count, err
	}
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Feedback.Count query done")
	if rows.Next() {
		log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Feedback.Count row found")
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Feedback.Count context error")
			return count, err
		}
		err = rows.Scan(&count)
		log.WithFields(log.Fields{"count": count}).Debug("repo.Feedback.Count result obtained")

		if err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "error": err}).Error("repo.Feedback.Count scan error")
			return count, err
		}
	}
	return count, nil
}

// ListWithRel returns a slice containing Feedback records; will also load related entities.
func (repo FeedbackRepositorium) ListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Feedback, error) {
	var (
		err      error
		entities []*Feedback
	)

	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Feedback.ListWithRel entered")
	entities, err = repo.List(ctx, opts, filters...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Feedback.ListWithRel get entity error")
		return nil, err
	}

	err = repo.LoadVisitor(ctx, entities...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Feedback.ListWithRel list related Visitor error")
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Feedback.ListWithRel context error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Feedback.ListWithRel related Visitor listed")

	return entities, nil
}

// Select returns a slice containing Feedback records according to a custom SQL condition
func (repo FeedbackRepositorium) Select(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Feedback, error) {
	var (
		list []*Feedback
		err  error
		rows *sql.Rows
	)

	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Feedback.Select entered")
	query := `SELECT t."id", t."status", t."user_id", t."created_at", t."session_id", t."reaction1", t."reaction2", t."reaction3", t."reaction4", t."visitor_id" FROM feedbacks t ` + condition
	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Info("repo.Feedback.Select context error")
		return nil, err
	}

	if opts != nil {
		query += opts.SortOpts(func(field string) bool {
			switch field { //TODO SQL-dialect sensitive
			case "id", "status", "user_id", "created_at", "session_id", "reaction1", "reaction2", "reaction3", "reaction4", "visitor_id":
				return true
			}

			return false
		})
	}

	if opts != nil && opts.Offset > 0 { //TODO SQL-dialect sensitive
		query += " OFFSET " + strconv.FormatInt(opts.Offset, 10)
	}

	if opts != nil && opts.Limit > 0 { //TODO SQL-dialect sensitive
		query += " LIMIT " + strconv.FormatInt(opts.Limit, 10)
	}

	rows, err = repo.db.QueryContext(ctx, query, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "query": query, "error": err}).Error("repo.Feedback.Select query error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Feedback.Select query done")

	defer rows.Close()
	for rows.Next() {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Info("repo.Feedback.Select context error")
			return nil, err
		}

		var entity Feedback
		var createdat time.Time

		err = rows.Scan(&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.SessionID, &entity.Reaction1, &entity.Reaction2, &entity.Reaction3, &entity.Reaction4, &entity.VisitorID)
		if err != nil {
			log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "query": query, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.SessionID, &entity.Reaction1, &entity.Reaction2, &entity.Reaction3, &entity.Reaction4, &entity.VisitorID", "error": err}).Error("repo.Feedback.Select scan error")
			return nil, err
		}

		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)

		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Feedback.Select data scan done")
		list = append(list, &entity)
	}

	return list, nil
}

// SelectWithRel returns a slice containing Feedback records according to a custom SQL condition; will also load related entities.
func (repo FeedbackRepositorium) SelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Feedback, error) {
	var (
		err      error
		entities []*Feedback
	)

	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Feedback.SelectWithRel entered")
	entities, err = repo.Select(ctx, opts, condition, values...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Error("repo.Feedback.SelectWithRel get entity error")
		return nil, err
	}

	err = repo.LoadVisitor(ctx, entities...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Error("repo.Feedback.SelectWithRel list related Visitor error")
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Info("repo.Feedback.SelectWithRel context error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Feedback.SelectWithRel related Visitor listed")

	return entities, nil
}

// Delete deletes a Feedback record from database and sets id to nil
func (repo FeedbackRepositorium) Delete(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)
	id := entity.ID

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.Delete entered")
	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Delete context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Delete StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Delete context error")
		return errors.WithStack(err)
	}

	stmt, err = tx.Prepare("DELETE FROM feedbacks WHERE id = $1")
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `DELETE FROM feedbacks WHERE id = $1`, "error": err}).Error("repo.Feedback.Delete query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Delete context error")
		return errors.WithStack(err)
	}

	_, err = stmt.Exec(id)
	if err == nil {
		entity.ID = ""
	} else {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Delete query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Delete context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Delete commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// DeleteMany deletes many Feedback records from database using filter
func (repo FeedbackRepositorium) DeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error {
	var (
		err       error
		stmt      *sql.Stmt
		segments  []string
		values    []interface{}
		query     string
		committed bool
	)

	log.WithFields(log.Fields{"filters": filters}).Debug("repo.Feedback.DeleteMany entered")
	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Feedback.DeleteMany context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Feedback.DeleteMany StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Feedback.DeleteMany context error")
		return errors.WithStack(err)
	}

	for i, filter := range filters {
		segments = append(segments, filter.Field+" "+filter.Operation+" $"+strconv.Itoa(i+1))
		values = append(values, filter.Value)
	}

	if len(segments) != 0 { //TODO SQL-dialect sensitive
		query = " WHERE " + strings.Join(segments, " AND ")
	}

	stmt, err = tx.Prepare("DELETE FROM feedbacks" + query)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"filters": filters, "query": "DELETE FROM feedbacks" + query + ")", "error": err}).Error("repo.Feedback.DeleteMany query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Feedback.DeleteMany context error")
		return errors.WithStack(err)
	}

	_, err = stmt.Exec(values...)
	if err != nil {
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Feedback.DeleteMany context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Feedback.DeleteMany commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// Save either inserts or updates a Feedback record based on whether or not id is nil
func (repo FeedbackRepositorium) Save(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error {
	if entity == nil {
		return moderrors.SaveEmptyEntityError
	}

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.Save entered")
	if entity.ID == "" {
		return repo.Insert(ctx, entity, tx, autocommit)
	}
	return repo.Update(ctx, entity, tx, autocommit)
}

// SaveWithRel either inserts or updates a Feedback record based on whether or not id is nil; will also save related entities
func (repo FeedbackRepositorium) SaveWithRel(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error {
	if entity == nil {
		return moderrors.SaveEmptyEntityError
	}

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.SaveWithRel entered")
	if entity.ID == "" {
		return repo.InsertWithRel(ctx, entity, tx, autocommit)
	}
	return repo.UpdateWithRel(ctx, entity, tx, autocommit)
}

// Update Will execute an SQLUpdate Statement for Feedback in the database. Prefer using Save instead of Update directly.
func (repo FeedbackRepositorium) Update(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.Update entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Feedback.Update Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Update context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Update StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`UPDATE feedbacks SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "session_id" = $6, "reaction1" = $7, "reaction2" = $8, "reaction3" = $9, "reaction4" = $10, "visitor_id" = $11 WHERE id = $1`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `UPDATE feedbacks SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "session_id" = $6, "reaction1" = $7, "reaction2" = $8, "reaction3" = $9, "reaction4" = $10, "visitor_id" = $11 WHERE id = $1`, "error": err}).Error("repo.Feedback.Update query error")
		return errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.Update query done")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Update context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.ID, entity.Status, entity.UserID, createdat, entity.SessionID, entity.Reaction1, entity.Reaction2, entity.Reaction3, entity.Reaction4, entity.VisitorID)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Update query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Update context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Update commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// UpdateWithRel Will execute an SQLUpdate Statement for Feedback in the database; including related entities. Prefer using Save instead of Update directly.
func (repo FeedbackRepositorium) UpdateWithRel(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.UpdateWithRel entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Feedback.UpdateWithRel Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.UpdateWithRel context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.UpdateWithRel StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`UPDATE feedbacks SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "session_id" = $6, "reaction1" = $7, "reaction2" = $8, "reaction3" = $9, "reaction4" = $10, "visitor_id" = $11 WHERE id = $1`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `UPDATE feedbacks SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "session_id" = $6, "reaction1" = $7, "reaction2" = $8, "reaction3" = $9, "reaction4" = $10, "visitor_id" = $11 WHERE id = $1`, "error": err}).Error("repo.Feedback.UpdateWithRel query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.UpdateWithRel context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.ID, entity.Status, entity.UserID, createdat, entity.SessionID, entity.Reaction1, entity.Reaction2, entity.Reaction3, entity.Reaction4, entity.VisitorID)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.UpdateWithRel query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.UpdateWithRel context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.UpdateWithRel commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// Merge performs an SQL merge for Feedback record.
func (repo FeedbackRepositorium) Merge(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.Merge entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Feedback.Merge Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Merge context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Merge StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if entity.ID == "" {
		return FeedbackRepo.Insert(ctx, entity, tx, autocommit)
	}

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`INSERT INTO feedbacks (id, status, user_id, created_at, session_id, reaction1, reaction2, reaction3, reaction4, "visitor_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "session_id" = $5, "reaction1" = $6, "reaction2" = $7, "reaction3" = $8, "reaction4" = $9, "visitor_id" = $10`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO feedbacks (id, status, user_id, created_at, session_id, reaction1, reaction2, reaction3, reaction4, "visitor_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "session_id" = $5, "reaction1" = $6, "reaction2" = $7, "reaction3" = $8, "reaction4" = $9, "visitor_id" = $10`, "error": err}).Error("repo.Feedback.Merge query error")
		return errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.Merge query done")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Merge context error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Merge context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.Status, entity.UserID, createdat, entity.SessionID, entity.Reaction1, entity.Reaction2, entity.Reaction3, entity.Reaction4, entity.VisitorID)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Merge query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Merge context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Merge commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// MergeWithRel performs an SQL merge for Feedback record.
func (repo FeedbackRepositorium) MergeWithRel(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Feedback.MergeWithRel entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Feedback.MergeWithRel Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.Merge context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.MergeWithRel StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if entity.ID == "" {
		return FeedbackRepo.Insert(ctx, entity, tx, autocommit)
	}

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`INSERT INTO feedbacks (id, status, user_id, created_at, session_id, reaction1, reaction2, reaction3, reaction4, "visitor_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "session_id" = $5, "reaction1" = $6, "reaction2" = $7, "reaction3" = $8, "reaction4" = $9, "visitor_id" = $10`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO feedbacks (id, status, user_id, created_at, session_id, reaction1, reaction2, reaction3, reaction4, "visitor_id") VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "session_id" = $5, "reaction1" = $6, "reaction2" = $7, "reaction3" = $8, "reaction4" = $9, "visitor_id" = $10`, "error": err}).Error("repo.Feedback.MergeWithRel query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.MergeWithRel context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.Status, entity.UserID, createdat, entity.SessionID, entity.Reaction1, entity.Reaction2, entity.Reaction3, entity.Reaction4, entity.VisitorID)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.MergeWithRel query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.MergeWithRel context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Feedback.MergeWithRel commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// LoadVisitor is a helper function to load related Visitor entities (many-one relationship)
func (repo FeedbackRepositorium) LoadVisitor(ctx context.Context, entities ...*Feedback) error {
	var (
		err         error
		placeholder string
		values      []interface{}
		indices     = make(map[string][]*Feedback)
	)

	log.WithFields(log.Fields{"entities": entities}).Debug("repo.Feedback.Load entered")
	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entities": entities, "error": err}).Info("repo.Feedback.Load context error")
		return errors.WithStack(err)
	} else if len(entities) == 0 {
		return nil
	}

	c := 1
	for _, entity := range entities {
		placeholder += "$" + strconv.Itoa(c) + ","
		indices[entity.VisitorID] = append(indices[entity.VisitorID], entity)
		values = append(values, entity.VisitorID)
		c++
	}
	placeholder = strings.TrimRight(placeholder, ",")
	rows, err := repo.db.QueryContext(ctx, `
		SELECT t."id", t."id", t."status", t."user_id", t."created_at", t."name", t."bookmark", t."photo_link" FROM visitors t WHERE t."id" IN (`+placeholder+`)
	`, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"entities": entities, "query": `SELECT t."id", t."id", t."status", t."user_id", t."created_at", t."name", t."bookmark", t."photo_link" FROM visitors t WHERE t."id" IN (` + placeholder + `)`, "error": err}).Error("repo.Feedback.Load query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entities": entities, "error": err}).Info("repo.Feedback.Load context error")
		return errors.WithStack(err)
	}

	for rows.Next() {
		var (
			thatID string
			entity Visitor
		)
		var createdat time.Time

		err = rows.Scan(&thatID, &entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.Name, &entity.Bookmark, &entity.PhotoLink)
		if err != nil {
			log.WithFields(log.Fields{"entities": entities, "query": `SELECT t."id", t."id", t."status", t."user_id", t."created_at", t."name", t."bookmark", t."photo_link" FROM visitors t WHERE t."id" IN (` + placeholder + `)`, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.Name, &entity.Bookmark, &entity.PhotoLink", "error": err}).Error("repo.Feedback.Load scan error")
			return errors.WithStack(err)
		}
		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)

		for i := range indices[thatID] {
			indices[thatID][i].Visitor = &entity
		}

		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entities": entities, "error": err}).Info("repo.Feedback.Load context error")
			return errors.WithStack(err)
		}
	}

	return nil
}

// [END] Feedback

// [BEGIN] Visitor

// Insert performs an SQL insert for Visitor record and update instance with inserted id. Prefer using Save instead of Insert directly.
func (repo VisitorRepositorium) Insert(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.Insert entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Visitor.Insert Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Insert context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Insert StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()
	entity.CreatedAt = ptypes.TimestampNow()
	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`INSERT INTO visitors ("id", "status", "user_id", "created_at", "name", "bookmark", "photo_link") VALUES ($1, $2, $3, $4, $5, $6, $7)`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO visitors ("id", "status", "user_id", "created_at", "name", "bookmark", "photo_link") VALUES ($1, $2, $3, $4, $5, $6, $7)`, "error": err}).Error("repo.Visitor.Insert query error")
		return errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.Insert query done")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Insert context error")
		return errors.WithStack(err)
	}

	entity.ID = uuid.NewV4().String()

	_, err = stmt.Exec(entity.ID, entity.Status, entity.UserID, createdat, entity.Name, entity.Bookmark, entity.PhotoLink)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Insert query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Insert context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Insert commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// InsertWithRel performs an SQL insert for Visitor record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.
func (repo VisitorRepositorium) InsertWithRel(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error {
	var (
		id        string
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.InsertWithRel entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Visitor.InsertWithRel Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.InsertWithRel context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.InsertWithRel StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()
	entity.CreatedAt = ptypes.TimestampNow()
	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`INSERT INTO visitors ("id", "status", "user_id", "created_at", "name", "bookmark", "photo_link") VALUES ($1, $2, $3, $4, $5, $6, $7)`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO visitors ("id", "status", "user_id", "created_at", "name", "bookmark", "photo_link") VALUES ($1, $2, $3, $4, $5, $6, $7)`, "error": err}).Error("repo.Visitor.InsertWithRel query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.InsertWithRel context error")
		return errors.WithStack(err)
	}
	idUUID := uuid.NewV4()
	id = idUUID.String()
	entity.ID = id

	_, err = stmt.Exec(&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.Name, &entity.Bookmark, &entity.PhotoLink)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.InsertWithRel query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.InsertWithRel context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.InsertWithRel commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// Get returns a single Visitor from database by primary key
func (repo VisitorRepositorium) Get(ctx context.Context, id string) (*Visitor, error) {
	var (
		rows   *sql.Rows
		err    error
		entity Visitor
	)

	log.WithFields(log.Fields{"id": id}).Debug("repo.Visitor.Get entered")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Info("repo.Visitor.Get context error")
		return nil, err
	}

	rows, err = repo.db.QueryContext(ctx, `SELECT t."id", t."status", t."user_id", t."created_at", t."name", t."bookmark", t."photo_link" FROM visitors t WHERE t."id" = $1 ORDER BY t."id" ASC`, id)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"id": id, "query": `SELECT t."id", t."status", t."user_id", t."created_at", t."name", t."bookmark", t."photo_link" FROM visitors t WHERE t."id" = $1 ORDER BY t."id" ASC`, "error": err}).Error("repo.Visitor.Get query error")
		return nil, err
	}
	log.WithFields(log.Fields{"id": id}).Debug("repo.Visitor.Get query done")
	if rows.Next() {
		log.WithFields(log.Fields{"id": id}).Debug("repo.Visitor.Get row found")
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"id": id, "error": err}).Info("repo.Visitor.Get context error")
			return nil, err
		}

		var createdat time.Time

		err = rows.Scan(&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.Name, &entity.Bookmark, &entity.PhotoLink)
		if err != nil {
			log.WithFields(log.Fields{"id": id, "query": `SELECT t."id", t."status", t."user_id", t."created_at", t."name", t."bookmark", t."photo_link" FROM visitors t WHERE t."id" = $1 ORDER BY t."id" ASC`, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.Name, &entity.Bookmark, &entity.PhotoLink", "error": err}).Error("repo.Visitor.Get scan error")
			return nil, err
		}

		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)

		log.WithFields(log.Fields{"id": id}).Debug("repo.Visitor.Get data scan done")
	} else {
		log.WithFields(log.Fields{"id": id}).Debug("repo.Visitor.Get data not found")
		return nil, moderrors.RecordNotFoundError
	}

	return &entity, nil
}

// GetWithRel returns a single Visitor from database by primary key; loads related entities
func (repo VisitorRepositorium) GetWithRel(ctx context.Context, id string) (*Visitor, error) {
	log.WithFields(log.Fields{"id": id}).Debug("repo.Visitor.GetWithRel entered")
	entity, err := repo.Get(ctx, id)
	if err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Error("repo.Visitor.GetWithRel get entity error")
		return nil, err
	}
	log.WithFields(log.Fields{"id": id}).Debug("repo.Visitor.GetWithRel entity loaded")

	err = repo.LoadFeedbacks(ctx, entity)
	if err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Error("repo.Visitor.Get load related Feedbacks error")
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Info("repo.Visitor.Get context error")
		return nil, err
	}
	log.WithFields(log.Fields{"id": id}).Debug("repo.Visitor.GetWithRel related Feedbacks loaded")

	return entity, nil
}

// List returns a slice containing Visitor records
func (repo VisitorRepositorium) List(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Visitor, error) {
	var (
		list     []*Visitor
		segments []string
		values   []interface{}
		err      error
		rows     *sql.Rows
		index    int = 0
	)

	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Visitor.List entered")
	query := `SELECT t."id", t."status", t."user_id", t."created_at", t."name", t."bookmark", t."photo_link" FROM visitors t`

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Visitor.List context error")
		return nil, err
	}

	for _, filter := range filters {
		switch filter.Field {
		default:
			continue
		case "id", "status", "user_id", "created_at", "name", "bookmark", "photo_link":
			//ok
		}

		if filter.Operation == "IN" || filter.Operation == "NOT IN" { //TODO SQL-dialect sensitive
			seg, val, err := QueryAddIN(segments, values, &index, `t."`+filter.Field+`"`, filter.Value, "NOT IN" == filter.Operation)
			if err != nil {
				log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Visitor.List QueryAddIN error")
				continue
			}
			segments = seg
			values = val
		} else {
			index++
			segments = append(segments, filter.ToQuerySegment(index))
			values = append(values, filter.Value)
		}
	}

	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}

	if opts != nil { //TODO SQL-dialect sensitive
		query += opts.SortOpts(func(field string) bool {
			switch field { //TODO SQL-dialect sensitive
			case "id", "status", "user_id", "created_at", "name", "bookmark", "photo_link":
				return true
			}

			return false
		})
	} else {
		query += ` ORDER BY t."created_at" ASC`
	}

	if opts != nil && opts.Offset > 0 { //TODO SQL-dialect sensitive
		query += " OFFSET " + strconv.FormatInt(opts.Offset, 10)
	}

	if opts != nil && opts.Limit > 0 { //TODO SQL-dialect sensitive
		query += " LIMIT " + strconv.FormatInt(opts.Limit, 10)
	}

	rows, err = repo.db.QueryContext(ctx, query, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "error": err}).Error("repo.Visitor.List query error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Visitor.List query done")

	for rows.Next() {
		log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Visitor.List row found")
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Visitor.List context error")
			return nil, err
		}

		var entity Visitor
		var createdat time.Time

		err = rows.Scan(&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.Name, &entity.Bookmark, &entity.PhotoLink)
		if err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.Name, &entity.Bookmark, &entity.PhotoLink", "error": err}).Error("repo.Visitor.List scan error")
			return nil, err
		}

		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)

		log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Visitor.List data scan done")
		list = append(list, &entity)

	}

	return list, nil
}

// Count returns a count of a query containing Visitor records
func (repo VisitorRepositorium) Count(ctx context.Context, opts *ListOpts, filters ...*Filter) (int64, error) {
	var (
		segments []string
		values   []interface{}
		err      error
		rows     *sql.Rows
		index    int = 0
		count    int64
	)
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Visitor.Count entered")
	query := `SELECT COUNT(id) FROM visitors t`
	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Visitor.Count context error")
		return count, err
	}
	for _, filter := range filters {
		switch filter.Field {
		default:
			continue
		case "id", "status", "user_id", "created_at", "name", "bookmark", "photo_link":
			//ok
		}

		if filter.Operation == "IN" || filter.Operation == "NOT IN" {
			seg, val, err := QueryAddIN(segments, values, &index, filter.Field, filter.Value, "NOT IN" == filter.Operation)
			if err != nil {
				log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Visitor.Count QueryAddIN error")
				continue
			}
			segments = seg
			values = val
		} else {
			index++
			segments = append(segments, filter.Field+" "+filter.Operation+" $"+strconv.Itoa(index))
			values = append(values, filter.Value)
		}
	}
	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}
	rows, err = repo.db.QueryContext(ctx, query, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "error": err}).Error("repo.Visitor.Count query error")
		return count, err
	}
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Visitor.Count query done")
	if rows.Next() {
		log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Visitor.Count row found")
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Visitor.Count context error")
			return count, err
		}
		err = rows.Scan(&count)
		log.WithFields(log.Fields{"count": count}).Debug("repo.Visitor.Count result obtained")

		if err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "error": err}).Error("repo.Visitor.Count scan error")
			return count, err
		}
	}
	return count, nil
}

// ListWithRel returns a slice containing Visitor records; will also load related entities.
func (repo VisitorRepositorium) ListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Visitor, error) {
	var (
		err      error
		entities []*Visitor
	)

	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Visitor.ListWithRel entered")
	entities, err = repo.List(ctx, opts, filters...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Visitor.ListWithRel get entity error")
		return nil, err
	}

	err = repo.LoadFeedbacks(ctx, entities...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Visitor.ListWithRel list related Feedbacks error")
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Visitor.ListWithRel context error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Visitor.ListWithRel related Feedbacks listed")

	return entities, nil
}

// Select returns a slice containing Visitor records according to a custom SQL condition
func (repo VisitorRepositorium) Select(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Visitor, error) {
	var (
		list []*Visitor
		err  error
		rows *sql.Rows
	)

	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Visitor.Select entered")
	query := `SELECT t."id", t."status", t."user_id", t."created_at", t."name", t."bookmark", t."photo_link" FROM visitors t ` + condition
	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Info("repo.Visitor.Select context error")
		return nil, err
	}

	if opts != nil {
		query += opts.SortOpts(func(field string) bool {
			switch field { //TODO SQL-dialect sensitive
			case "id", "status", "user_id", "created_at", "name", "bookmark", "photo_link":
				return true
			}

			return false
		})
	}

	if opts != nil && opts.Offset > 0 { //TODO SQL-dialect sensitive
		query += " OFFSET " + strconv.FormatInt(opts.Offset, 10)
	}

	if opts != nil && opts.Limit > 0 { //TODO SQL-dialect sensitive
		query += " LIMIT " + strconv.FormatInt(opts.Limit, 10)
	}

	rows, err = repo.db.QueryContext(ctx, query, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "query": query, "error": err}).Error("repo.Visitor.Select query error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Visitor.Select query done")

	defer rows.Close()
	for rows.Next() {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Info("repo.Visitor.Select context error")
			return nil, err
		}

		var entity Visitor
		var createdat time.Time

		err = rows.Scan(&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.Name, &entity.Bookmark, &entity.PhotoLink)
		if err != nil {
			log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "query": query, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.Name, &entity.Bookmark, &entity.PhotoLink", "error": err}).Error("repo.Visitor.Select scan error")
			return nil, err
		}

		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)

		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Visitor.Select data scan done")
		list = append(list, &entity)
	}

	return list, nil
}

// SelectWithRel returns a slice containing Visitor records according to a custom SQL condition; will also load related entities.
func (repo VisitorRepositorium) SelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Visitor, error) {
	var (
		err      error
		entities []*Visitor
	)

	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Visitor.SelectWithRel entered")
	entities, err = repo.Select(ctx, opts, condition, values...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Error("repo.Visitor.SelectWithRel get entity error")
		return nil, err
	}

	err = repo.LoadFeedbacks(ctx, entities...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Error("repo.Visitor.SelectWithRel list related Feedbacks error")
		return nil, err
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Info("repo.Visitor.SelectWithRel context error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Visitor.SelectWithRel related Feedbacks listed")

	return entities, nil
}

// Delete deletes a Visitor record from database and sets id to nil
func (repo VisitorRepositorium) Delete(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)
	id := entity.ID

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.Delete entered")
	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Delete context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Delete StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Delete context error")
		return errors.WithStack(err)
	}

	stmt, err = tx.Prepare("DELETE FROM visitors WHERE id = $1")
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `DELETE FROM visitors WHERE id = $1`, "error": err}).Error("repo.Visitor.Delete query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Delete context error")
		return errors.WithStack(err)
	}

	_, err = stmt.Exec(id)
	if err == nil {
		entity.ID = ""
	} else {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Delete query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Delete context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Delete commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// DeleteMany deletes many Visitor records from database using filter
func (repo VisitorRepositorium) DeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error {
	var (
		err       error
		stmt      *sql.Stmt
		segments  []string
		values    []interface{}
		query     string
		committed bool
	)

	log.WithFields(log.Fields{"filters": filters}).Debug("repo.Visitor.DeleteMany entered")
	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Visitor.DeleteMany context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Visitor.DeleteMany StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Visitor.DeleteMany context error")
		return errors.WithStack(err)
	}

	for i, filter := range filters {
		segments = append(segments, filter.Field+" "+filter.Operation+" $"+strconv.Itoa(i+1))
		values = append(values, filter.Value)
	}

	if len(segments) != 0 { //TODO SQL-dialect sensitive
		query = " WHERE " + strings.Join(segments, " AND ")
	}

	stmt, err = tx.Prepare("DELETE FROM visitors" + query)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"filters": filters, "query": "DELETE FROM visitors" + query + ")", "error": err}).Error("repo.Visitor.DeleteMany query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Visitor.DeleteMany context error")
		return errors.WithStack(err)
	}

	_, err = stmt.Exec(values...)
	if err != nil {
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Visitor.DeleteMany context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Visitor.DeleteMany commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// Save either inserts or updates a Visitor record based on whether or not id is nil
func (repo VisitorRepositorium) Save(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error {
	if entity == nil {
		return moderrors.SaveEmptyEntityError
	}

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.Save entered")
	if entity.ID == "" {
		return repo.Insert(ctx, entity, tx, autocommit)
	}
	return repo.Update(ctx, entity, tx, autocommit)
}

// SaveWithRel either inserts or updates a Visitor record based on whether or not id is nil; will also save related entities
func (repo VisitorRepositorium) SaveWithRel(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error {
	if entity == nil {
		return moderrors.SaveEmptyEntityError
	}

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.SaveWithRel entered")
	if entity.ID == "" {
		return repo.InsertWithRel(ctx, entity, tx, autocommit)
	}
	return repo.UpdateWithRel(ctx, entity, tx, autocommit)
}

// Update Will execute an SQLUpdate Statement for Visitor in the database. Prefer using Save instead of Update directly.
func (repo VisitorRepositorium) Update(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.Update entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Visitor.Update Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Update context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Update StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`UPDATE visitors SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "name" = $6, "bookmark" = $7, "photo_link" = $8 WHERE id = $1`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `UPDATE visitors SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "name" = $6, "bookmark" = $7, "photo_link" = $8 WHERE id = $1`, "error": err}).Error("repo.Visitor.Update query error")
		return errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.Update query done")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Update context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.ID, entity.Status, entity.UserID, createdat, entity.Name, entity.Bookmark, entity.PhotoLink)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Update query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Update context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Update commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// UpdateWithRel Will execute an SQLUpdate Statement for Visitor in the database; including related entities. Prefer using Save instead of Update directly.
func (repo VisitorRepositorium) UpdateWithRel(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.UpdateWithRel entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Visitor.UpdateWithRel Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.UpdateWithRel context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.UpdateWithRel StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`UPDATE visitors SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "name" = $6, "bookmark" = $7, "photo_link" = $8 WHERE id = $1`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `UPDATE visitors SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "name" = $6, "bookmark" = $7, "photo_link" = $8 WHERE id = $1`, "error": err}).Error("repo.Visitor.UpdateWithRel query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.UpdateWithRel context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.ID, entity.Status, entity.UserID, createdat, entity.Name, entity.Bookmark, entity.PhotoLink)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.UpdateWithRel query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.UpdateWithRel context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.UpdateWithRel commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// Merge performs an SQL merge for Visitor record.
func (repo VisitorRepositorium) Merge(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.Merge entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Visitor.Merge Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Merge context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Merge StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if entity.ID == "" {
		return VisitorRepo.Insert(ctx, entity, tx, autocommit)
	}

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`INSERT INTO visitors (id, status, user_id, created_at, name, bookmark, photo_link) VALUES ($1, $2, $3, $4, $5, $6, $7) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "name" = $5, "bookmark" = $6, "photo_link" = $7`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO visitors (id, status, user_id, created_at, name, bookmark, photo_link) VALUES ($1, $2, $3, $4, $5, $6, $7) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "name" = $5, "bookmark" = $6, "photo_link" = $7`, "error": err}).Error("repo.Visitor.Merge query error")
		return errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.Merge query done")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Merge context error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Merge context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.Status, entity.UserID, createdat, entity.Name, entity.Bookmark, entity.PhotoLink)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Merge query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Merge context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Merge commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// MergeWithRel performs an SQL merge for Visitor record.
func (repo VisitorRepositorium) MergeWithRel(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Visitor.MergeWithRel entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Visitor.MergeWithRel Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.Merge context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.MergeWithRel StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if entity.ID == "" {
		return VisitorRepo.Insert(ctx, entity, tx, autocommit)
	}

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)

	stmt, err = tx.Prepare(`INSERT INTO visitors (id, status, user_id, created_at, name, bookmark, photo_link) VALUES ($1, $2, $3, $4, $5, $6, $7) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "name" = $5, "bookmark" = $6, "photo_link" = $7`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO visitors (id, status, user_id, created_at, name, bookmark, photo_link) VALUES ($1, $2, $3, $4, $5, $6, $7) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "name" = $5, "bookmark" = $6, "photo_link" = $7`, "error": err}).Error("repo.Visitor.MergeWithRel query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.MergeWithRel context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.Status, entity.UserID, createdat, entity.Name, entity.Bookmark, entity.PhotoLink)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.MergeWithRel query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.MergeWithRel context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Visitor.MergeWithRel commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// LoadFeedbacks is a helper function to load related Feedbacks entities (one-many relationship)
func (repo VisitorRepositorium) LoadFeedbacks(ctx context.Context, entities ...*Visitor) error {
	var (
		err         error
		placeholder string
		values      []interface{}
		indices     = make(map[string][]*Visitor)
	)

	log.WithFields(log.Fields{"entities": entities}).Debug("repo.Visitor.Load entered")
	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entities": entities, "error": err}).Info("repo.Visitor.Load context error")
		return errors.WithStack(err)
	} else if len(entities) == 0 {
		return nil
	}

	c := 1
	for _, entity := range entities {
		placeholder += "$" + strconv.Itoa(c) + ","
		indices[entity.ID] = append(indices[entity.ID], entity)
		values = append(values, entity.ID)
		c++
	}
	placeholder = strings.TrimRight(placeholder, ",")

	rows, err := repo.db.QueryContext(ctx, `
		SELECT t."visitor_id", t."id", t."status", t."user_id", t."created_at", t."session_id", t."reaction1", t."reaction2", t."reaction3", t."reaction4", t."visitor_id" FROM feedbacks t WHERE t."visitor_id" IN (`+placeholder+`)
	`, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"entities": entities, "query": `SELECT t."visitor_id", t."id", t."status", t."user_id", t."created_at", t."session_id", t."reaction1", t."reaction2", t."reaction3", t."reaction4", t."visitor_id" FROM feedbacks t WHERE t."visitor_id" IN (` + placeholder + `)`, "error": err}).Error("repo.Visitor.Load query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entities": entities, "error": err}).Info("repo.Visitor.Load context error")
		return errors.WithStack(err)
	}

	for rows.Next() {
		var (
			thisID string
			entity Feedback
		)

		var createdat time.Time

		err = rows.Scan(&thisID, &entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.SessionID, &entity.Reaction1, &entity.Reaction2, &entity.Reaction3, &entity.Reaction4, &entity.VisitorID)
		if err != nil {
			log.WithFields(log.Fields{"entities": entities, "query": `SELECT t."visitor_id", t."id", t."status", t."user_id", t."created_at", t."session_id", t."reaction1", t."reaction2", t."reaction3", t."reaction4", t."visitor_id" FROM feedbacks t WHERE t."visitor_id" IN (` + placeholder + `)`, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &entity.SessionID, &entity.Reaction1, &entity.Reaction2, &entity.Reaction3, &entity.Reaction4, &entity.VisitorID", "error": err}).Error("repo.Visitor.Load scan error")
			return errors.WithStack(err)
		}
		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)

		for i := range indices[thisID] {
			indices[thisID][i].Feedbacks = append(indices[thisID][i].Feedbacks, &entity)
		}

		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entities": entities, "error": err}).Info("repo.Visitor.Load context error")
			return errors.WithStack(err)
		}
	}

	return nil
}

// [END] Visitor

// [BEGIN] Rating

// Insert performs an SQL insert for Rating record and update instance with inserted id. Prefer using Save instead of Insert directly.
func (repo RatingRepositorium) Insert(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.Insert entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Rating.Insert Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Insert context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Insert StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()
	entity.CreatedAt = ptypes.TimestampNow()
	createdat, _ := ptypes.Timestamp(entity.CreatedAt)
	entity.UpdatedAt = ptypes.TimestampNow()
	updatedat, _ := ptypes.Timestamp(entity.UpdatedAt)

	stmt, err = tx.Prepare(`INSERT INTO ratings ("id", "status", "user_id", "created_at", "updated_at", "rating_count", "score", "reaction_summary") VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO ratings ("id", "status", "user_id", "created_at", "updated_at", "rating_count", "score", "reaction_summary") VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`, "error": err}).Error("repo.Rating.Insert query error")
		return errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.Insert query done")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Insert context error")
		return errors.WithStack(err)
	}

	entity.ID = uuid.NewV4().String()

	_, err = stmt.Exec(entity.ID, entity.Status, entity.UserID, createdat, updatedat, entity.RatingCount, entity.Score, entity.ReactionSummary)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Insert query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Insert context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Insert commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// InsertWithRel performs an SQL insert for Rating record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.
func (repo RatingRepositorium) InsertWithRel(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error {
	var (
		id        string
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.InsertWithRel entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Rating.InsertWithRel Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.InsertWithRel context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.InsertWithRel StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()
	entity.CreatedAt = ptypes.TimestampNow()
	createdat, _ := ptypes.Timestamp(entity.CreatedAt)
	entity.UpdatedAt = ptypes.TimestampNow()
	updatedat, _ := ptypes.Timestamp(entity.UpdatedAt)

	stmt, err = tx.Prepare(`INSERT INTO ratings ("id", "status", "user_id", "created_at", "updated_at", "rating_count", "score", "reaction_summary") VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO ratings ("id", "status", "user_id", "created_at", "updated_at", "rating_count", "score", "reaction_summary") VALUES ($1, $2, $3, $4, $5, $6, $7, $8)`, "error": err}).Error("repo.Rating.InsertWithRel query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.InsertWithRel context error")
		return errors.WithStack(err)
	}
	idUUID := uuid.NewV4()
	id = idUUID.String()
	entity.ID = id

	_, err = stmt.Exec(&entity.ID, &entity.Status, &entity.UserID, &createdat, &updatedat, &entity.RatingCount, &entity.Score, &entity.ReactionSummary)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.InsertWithRel query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.InsertWithRel context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.InsertWithRel commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// Get returns a single Rating from database by primary key
func (repo RatingRepositorium) Get(ctx context.Context, id string) (*Rating, error) {
	var (
		rows   *sql.Rows
		err    error
		entity Rating
	)

	log.WithFields(log.Fields{"id": id}).Debug("repo.Rating.Get entered")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Info("repo.Rating.Get context error")
		return nil, err
	}

	rows, err = repo.db.QueryContext(ctx, `SELECT t."id", t."status", t."user_id", t."created_at", t."updated_at", t."rating_count", t."score", t."reaction_summary" FROM ratings t WHERE t."id" = $1 ORDER BY t."id" ASC`, id)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"id": id, "query": `SELECT t."id", t."status", t."user_id", t."created_at", t."updated_at", t."rating_count", t."score", t."reaction_summary" FROM ratings t WHERE t."id" = $1 ORDER BY t."id" ASC`, "error": err}).Error("repo.Rating.Get query error")
		return nil, err
	}
	log.WithFields(log.Fields{"id": id}).Debug("repo.Rating.Get query done")
	if rows.Next() {
		log.WithFields(log.Fields{"id": id}).Debug("repo.Rating.Get row found")
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"id": id, "error": err}).Info("repo.Rating.Get context error")
			return nil, err
		}

		var createdat time.Time
		entity.UpdatedAt = ptypes.TimestampNow()
		var updatedat time.Time

		err = rows.Scan(&entity.ID, &entity.Status, &entity.UserID, &createdat, &updatedat, &entity.RatingCount, &entity.Score, &entity.ReactionSummary)
		if err != nil {
			log.WithFields(log.Fields{"id": id, "query": `SELECT t."id", t."status", t."user_id", t."created_at", t."updated_at", t."rating_count", t."score", t."reaction_summary" FROM ratings t WHERE t."id" = $1 ORDER BY t."id" ASC`, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &updatedat, &entity.RatingCount, &entity.Score, &entity.ReactionSummary", "error": err}).Error("repo.Rating.Get scan error")
			return nil, err
		}

		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)
		entity.UpdatedAt, _ = ptypes.TimestampProto(updatedat)

		log.WithFields(log.Fields{"id": id}).Debug("repo.Rating.Get data scan done")
	} else {
		log.WithFields(log.Fields{"id": id}).Debug("repo.Rating.Get data not found")
		return nil, moderrors.RecordNotFoundError
	}

	return &entity, nil
}

// GetWithRel returns a single Rating from database by primary key; loads related entities
func (repo RatingRepositorium) GetWithRel(ctx context.Context, id string) (*Rating, error) {
	log.WithFields(log.Fields{"id": id}).Debug("repo.Rating.GetWithRel entered")
	entity, err := repo.Get(ctx, id)
	if err != nil {
		log.WithFields(log.Fields{"id": id, "error": err}).Error("repo.Rating.GetWithRel get entity error")
		return nil, err
	}
	log.WithFields(log.Fields{"id": id}).Debug("repo.Rating.GetWithRel entity loaded")

	return entity, nil
}

// List returns a slice containing Rating records
func (repo RatingRepositorium) List(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Rating, error) {
	var (
		list     []*Rating
		segments []string
		values   []interface{}
		err      error
		rows     *sql.Rows
		index    int = 0
	)

	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Rating.List entered")
	query := `SELECT t."id", t."status", t."user_id", t."created_at", t."updated_at", t."rating_count", t."score", t."reaction_summary" FROM ratings t`

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Rating.List context error")
		return nil, err
	}

	for _, filter := range filters {
		switch filter.Field {
		default:
			continue
		case "id", "status", "user_id", "created_at", "updated_at", "rating_count", "score", "reaction_summary":
			//ok
		}

		if filter.Operation == "IN" || filter.Operation == "NOT IN" { //TODO SQL-dialect sensitive
			seg, val, err := QueryAddIN(segments, values, &index, `t."`+filter.Field+`"`, filter.Value, "NOT IN" == filter.Operation)
			if err != nil {
				log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Rating.List QueryAddIN error")
				continue
			}
			segments = seg
			values = val
		} else {
			index++
			segments = append(segments, filter.ToQuerySegment(index))
			values = append(values, filter.Value)
		}
	}

	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}

	if opts != nil { //TODO SQL-dialect sensitive
		query += opts.SortOpts(func(field string) bool {
			switch field { //TODO SQL-dialect sensitive
			case "id", "status", "user_id", "created_at", "updated_at", "rating_count", "score", "reaction_summary":
				return true
			}

			return false
		})
	} else {
		query += ` ORDER BY t."updated_at" ASC`
	}

	if opts != nil && opts.Offset > 0 { //TODO SQL-dialect sensitive
		query += " OFFSET " + strconv.FormatInt(opts.Offset, 10)
	}

	if opts != nil && opts.Limit > 0 { //TODO SQL-dialect sensitive
		query += " LIMIT " + strconv.FormatInt(opts.Limit, 10)
	}

	rows, err = repo.db.QueryContext(ctx, query, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "error": err}).Error("repo.Rating.List query error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Rating.List query done")

	for rows.Next() {
		log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Rating.List row found")
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Rating.List context error")
			return nil, err
		}

		var entity Rating
		var createdat time.Time
		entity.UpdatedAt = ptypes.TimestampNow()
		var updatedat time.Time

		err = rows.Scan(&entity.ID, &entity.Status, &entity.UserID, &createdat, &updatedat, &entity.RatingCount, &entity.Score, &entity.ReactionSummary)
		if err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &updatedat, &entity.RatingCount, &entity.Score, &entity.ReactionSummary", "error": err}).Error("repo.Rating.List scan error")
			return nil, err
		}

		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)
		entity.UpdatedAt, _ = ptypes.TimestampProto(updatedat)

		log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Rating.List data scan done")
		list = append(list, &entity)

	}

	return list, nil
}

// Count returns a count of a query containing Rating records
func (repo RatingRepositorium) Count(ctx context.Context, opts *ListOpts, filters ...*Filter) (int64, error) {
	var (
		segments []string
		values   []interface{}
		err      error
		rows     *sql.Rows
		index    int = 0
		count    int64
	)
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Rating.Count entered")
	query := `SELECT COUNT(id) FROM ratings t`
	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Rating.Count context error")
		return count, err
	}
	for _, filter := range filters {
		switch filter.Field {
		default:
			continue
		case "id", "status", "user_id", "created_at", "updated_at", "rating_count", "score", "reaction_summary":
			//ok
		}

		if filter.Operation == "IN" || filter.Operation == "NOT IN" {
			seg, val, err := QueryAddIN(segments, values, &index, filter.Field, filter.Value, "NOT IN" == filter.Operation)
			if err != nil {
				log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Rating.Count QueryAddIN error")
				continue
			}
			segments = seg
			values = val
		} else {
			index++
			segments = append(segments, filter.Field+" "+filter.Operation+" $"+strconv.Itoa(index))
			values = append(values, filter.Value)
		}
	}
	if len(segments) != 0 {
		query += " WHERE " + strings.Join(segments, " AND ")
	}
	rows, err = repo.db.QueryContext(ctx, query, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "error": err}).Error("repo.Rating.Count query error")
		return count, err
	}
	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Rating.Count query done")
	if rows.Next() {
		log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Rating.Count row found")
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Info("repo.Rating.Count context error")
			return count, err
		}
		err = rows.Scan(&count)
		log.WithFields(log.Fields{"count": count}).Debug("repo.Rating.Count result obtained")

		if err != nil {
			log.WithFields(log.Fields{"opts": opts, "filters": filters, "query": query, "error": err}).Error("repo.Rating.Count scan error")
			return count, err
		}
	}
	return count, nil
}

// ListWithRel returns a slice containing Rating records; will also load related entities.
func (repo RatingRepositorium) ListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Rating, error) {
	var (
		err      error
		entities []*Rating
	)

	log.WithFields(log.Fields{"opts": opts, "filters": filters}).Debug("repo.Rating.ListWithRel entered")
	entities, err = repo.List(ctx, opts, filters...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "filters": filters, "error": err}).Error("repo.Rating.ListWithRel get entity error")
		return nil, err
	}

	return entities, nil
}

// Select returns a slice containing Rating records according to a custom SQL condition
func (repo RatingRepositorium) Select(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Rating, error) {
	var (
		list []*Rating
		err  error
		rows *sql.Rows
	)

	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Rating.Select entered")
	query := `SELECT t."id", t."status", t."user_id", t."created_at", t."updated_at", t."rating_count", t."score", t."reaction_summary" FROM ratings t ` + condition
	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Info("repo.Rating.Select context error")
		return nil, err
	}

	if opts != nil {
		query += opts.SortOpts(func(field string) bool {
			switch field { //TODO SQL-dialect sensitive
			case "id", "status", "user_id", "created_at", "updated_at", "rating_count", "score", "reaction_summary":
				return true
			}

			return false
		})
	}

	if opts != nil && opts.Offset > 0 { //TODO SQL-dialect sensitive
		query += " OFFSET " + strconv.FormatInt(opts.Offset, 10)
	}

	if opts != nil && opts.Limit > 0 { //TODO SQL-dialect sensitive
		query += " LIMIT " + strconv.FormatInt(opts.Limit, 10)
	}

	rows, err = repo.db.QueryContext(ctx, query, values...)
	defer rows.Close()
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "query": query, "error": err}).Error("repo.Rating.Select query error")
		return nil, err
	}
	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Rating.Select query done")

	defer rows.Close()
	for rows.Next() {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Info("repo.Rating.Select context error")
			return nil, err
		}

		var entity Rating
		var createdat time.Time
		entity.UpdatedAt = ptypes.TimestampNow()
		var updatedat time.Time

		err = rows.Scan(&entity.ID, &entity.Status, &entity.UserID, &createdat, &updatedat, &entity.RatingCount, &entity.Score, &entity.ReactionSummary)
		if err != nil {
			log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "query": query, "fields": "&entity.ID, &entity.Status, &entity.UserID, &createdat, &updatedat, &entity.RatingCount, &entity.Score, &entity.ReactionSummary", "error": err}).Error("repo.Rating.Select scan error")
			return nil, err
		}

		entity.CreatedAt, _ = ptypes.TimestampProto(createdat)
		entity.UpdatedAt, _ = ptypes.TimestampProto(updatedat)

		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Rating.Select data scan done")
		list = append(list, &entity)
	}

	return list, nil
}

// SelectWithRel returns a slice containing Rating records according to a custom SQL condition; will also load related entities.
func (repo RatingRepositorium) SelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Rating, error) {
	var (
		err      error
		entities []*Rating
	)

	log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values}).Debug("repo.Rating.SelectWithRel entered")
	entities, err = repo.Select(ctx, opts, condition, values...)
	if err != nil {
		log.WithFields(log.Fields{"opts": opts, "condition": condition, "values": values, "error": err}).Error("repo.Rating.SelectWithRel get entity error")
		return nil, err
	}

	return entities, nil
}

// Delete deletes a Rating record from database and sets id to nil
func (repo RatingRepositorium) Delete(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)
	id := entity.ID

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.Delete entered")
	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Delete context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Delete StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Delete context error")
		return errors.WithStack(err)
	}

	stmt, err = tx.Prepare("DELETE FROM ratings WHERE id = $1")
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `DELETE FROM ratings WHERE id = $1`, "error": err}).Error("repo.Rating.Delete query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Delete context error")
		return errors.WithStack(err)
	}

	_, err = stmt.Exec(id)
	if err == nil {
		entity.ID = ""
	} else {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Delete query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Delete context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Delete commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// DeleteMany deletes many Rating records from database using filter
func (repo RatingRepositorium) DeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error {
	var (
		err       error
		stmt      *sql.Stmt
		segments  []string
		values    []interface{}
		query     string
		committed bool
	)

	log.WithFields(log.Fields{"filters": filters}).Debug("repo.Rating.DeleteMany entered")
	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Rating.DeleteMany context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Rating.DeleteMany StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Rating.DeleteMany context error")
		return errors.WithStack(err)
	}

	for i, filter := range filters {
		segments = append(segments, filter.Field+" "+filter.Operation+" $"+strconv.Itoa(i+1))
		values = append(values, filter.Value)
	}

	if len(segments) != 0 { //TODO SQL-dialect sensitive
		query = " WHERE " + strings.Join(segments, " AND ")
	}

	stmt, err = tx.Prepare("DELETE FROM ratings" + query)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"filters": filters, "query": "DELETE FROM ratings" + query + ")", "error": err}).Error("repo.Rating.DeleteMany query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Rating.DeleteMany context error")
		return errors.WithStack(err)
	}

	_, err = stmt.Exec(values...)
	if err != nil {
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Rating.DeleteMany context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"filters": filters, "error": err}).Info("repo.Rating.DeleteMany commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// Save either inserts or updates a Rating record based on whether or not id is nil
func (repo RatingRepositorium) Save(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error {
	if entity == nil {
		return moderrors.SaveEmptyEntityError
	}

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.Save entered")
	if entity.ID == "" {
		return repo.Insert(ctx, entity, tx, autocommit)
	}
	return repo.Update(ctx, entity, tx, autocommit)
}

// SaveWithRel either inserts or updates a Rating record based on whether or not id is nil; will also save related entities
func (repo RatingRepositorium) SaveWithRel(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error {
	if entity == nil {
		return moderrors.SaveEmptyEntityError
	}

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.SaveWithRel entered")
	if entity.ID == "" {
		return repo.InsertWithRel(ctx, entity, tx, autocommit)
	}
	return repo.UpdateWithRel(ctx, entity, tx, autocommit)
}

// Update Will execute an SQLUpdate Statement for Rating in the database. Prefer using Save instead of Update directly.
func (repo RatingRepositorium) Update(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.Update entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Rating.Update Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Update context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Update StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)
	entity.UpdatedAt = ptypes.TimestampNow()
	updatedat, _ := ptypes.Timestamp(entity.UpdatedAt)

	stmt, err = tx.Prepare(`UPDATE ratings SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "updated_at" = $6, "rating_count" = $7, "score" = $8, "reaction_summary" = $9 WHERE id = $1`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `UPDATE ratings SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "updated_at" = $6, "rating_count" = $7, "score" = $8, "reaction_summary" = $9 WHERE id = $1`, "error": err}).Error("repo.Rating.Update query error")
		return errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.Update query done")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Update context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.ID, entity.Status, entity.UserID, createdat, updatedat, entity.RatingCount, entity.Score, entity.ReactionSummary)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Update query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Update context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Update commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// UpdateWithRel Will execute an SQLUpdate Statement for Rating in the database; including related entities. Prefer using Save instead of Update directly.
func (repo RatingRepositorium) UpdateWithRel(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.UpdateWithRel entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Rating.UpdateWithRel Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.UpdateWithRel context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.UpdateWithRel StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)
	entity.UpdatedAt = ptypes.TimestampNow()
	updatedat, _ := ptypes.Timestamp(entity.UpdatedAt)

	stmt, err = tx.Prepare(`UPDATE ratings SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "updated_at" = $6, "rating_count" = $7, "score" = $8, "reaction_summary" = $9 WHERE id = $1`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `UPDATE ratings SET "id" = $2, "status" = $3, "user_id" = $4, "created_at" = $5, "updated_at" = $6, "rating_count" = $7, "score" = $8, "reaction_summary" = $9 WHERE id = $1`, "error": err}).Error("repo.Rating.UpdateWithRel query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.UpdateWithRel context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.ID, entity.Status, entity.UserID, createdat, updatedat, entity.RatingCount, entity.Score, entity.ReactionSummary)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.UpdateWithRel query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.UpdateWithRel context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.UpdateWithRel commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// Merge performs an SQL merge for Rating record.
func (repo RatingRepositorium) Merge(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.Merge entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Rating.Merge Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Merge context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Merge StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if entity.ID == "" {
		return RatingRepo.Insert(ctx, entity, tx, autocommit)
	}

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)
	entity.UpdatedAt = ptypes.TimestampNow()
	updatedat, _ := ptypes.Timestamp(entity.UpdatedAt)

	stmt, err = tx.Prepare(`INSERT INTO ratings (id, status, user_id, created_at, updated_at, rating_count, score, reaction_summary) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "updated_at" = $5, "rating_count" = $6, "score" = $7, "reaction_summary" = $8`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO ratings (id, status, user_id, created_at, updated_at, rating_count, score, reaction_summary) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "updated_at" = $5, "rating_count" = $6, "score" = $7, "reaction_summary" = $8`, "error": err}).Error("repo.Rating.Merge query error")
		return errors.WithStack(err)
	}
	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.Merge query done")

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Merge context error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Merge context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.Status, entity.UserID, createdat, updatedat, entity.RatingCount, entity.Score, entity.ReactionSummary)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Merge query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Merge context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Merge commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// MergeWithRel performs an SQL merge for Rating record.
func (repo RatingRepositorium) MergeWithRel(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error {
	var (
		err       error
		stmt      *sql.Stmt
		committed bool
	)

	log.WithFields(log.Fields{"entity": entity}).Debug("repo.Rating.MergeWithRel entered")
	if entity == nil {
		log.WithFields(log.Fields{"entity": entity}).Info("repo.Rating.MergeWithRel Entity empty error")
		return moderrors.SaveEmptyEntityError
	}

	if tx == nil {
		if err = util.CheckContext(ctx); err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.Merge context error")
			return errors.WithStack(err)
		}

		tx, err = StartTransaction(ctx)
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.MergeWithRel StartTransaction error")
			return errors.WithStack(err)
		}
	}
	defer func() {
		if tx != nil && (autocommit && !committed) {
			tx.Rollback()
		}
	}()

	if entity.ID == "" {
		return RatingRepo.Insert(ctx, entity, tx, autocommit)
	}

	createdat, _ := ptypes.Timestamp(entity.CreatedAt)
	entity.UpdatedAt = ptypes.TimestampNow()
	updatedat, _ := ptypes.Timestamp(entity.UpdatedAt)

	stmt, err = tx.Prepare(`INSERT INTO ratings (id, status, user_id, created_at, updated_at, rating_count, score, reaction_summary) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "updated_at" = $5, "rating_count" = $6, "score" = $7, "reaction_summary" = $8`)
	defer stmt.Close()
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "query": `INSERT INTO ratings (id, status, user_id, created_at, updated_at, rating_count, score, reaction_summary) VALUES ($1, $2, $3, $4, $5, $6, $7, $8) 
		ON CONFLICT (id) DO UPDATE SET "id" = $1, "status" = $2, "user_id" = $3, "created_at" = $4, "updated_at" = $5, "rating_count" = $6, "score" = $7, "reaction_summary" = $8`, "error": err}).Error("repo.Rating.MergeWithRel query error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.MergeWithRel context error")
		return errors.WithStack(err)
	}
	_, err = stmt.Exec(entity.ID, entity.Status, entity.UserID, createdat, updatedat, entity.RatingCount, entity.Score, entity.ReactionSummary)
	if err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.MergeWithRel query exec error")
		return errors.WithStack(err)
	}

	if err = util.CheckContext(ctx); err != nil {
		log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.MergeWithRel context error")
		return errors.WithStack(err)
	}

	if autocommit {
		err = tx.Commit()
		if err != nil {
			log.WithFields(log.Fields{"entity": entity, "error": err}).Info("repo.Rating.MergeWithRel commit error")
		} else {
			committed = true
		}
	}

	return errors.WithStack(err)
}

// [END] Rating
