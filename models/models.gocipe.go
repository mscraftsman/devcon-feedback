// generated by gocipe; DO NOT EDIT

package models

import (
	"context"
	"database/sql"
	"strconv"
	"strings"

	"github.com/mscraftsman/devcon-feedback/models/moderrors"
)

var (
	db *sql.DB

	// FeedbackRepo provides interaction with database content repository for Feedback
	FeedbackRepo FeedbackRepository
	// VisitorRepo provides interaction with database content repository for Visitor
	VisitorRepo VisitorRepository
	// RatingRepo provides interaction with database content repository for Rating
	RatingRepo RatingRepository
)

const (
	// OperationMerge indicates a Merge save operation is under way
	OperationMerge byte = 'M'
	// OperationInsert indicates a Insert save operation is under way
	OperationInsert byte = 'I'
	// OperationUpdate indicates a Update save operation is under way
	OperationUpdate byte = 'U'

	// NoOffset indicates List/Select queries without offset clause
	NoOffset = -1
	// NoLimit indicates List/Select queries without limit clause
	NoLimit = -1

	// FilterFuncLower is a filter function for SQL, to produce lowercase
	FilterFuncLower = "LOWER"
)

// Filter represents a filter to apply during listing (crud)
type Filter struct {
	Field         string
	FieldFunction string
	Operation     string
	Value         interface{}
}

// ToQuerySegment will return a formatted SQL segment to be used in queries
func (f Filter) ToQuerySegment(index int) string {
	var fieldPrefix, fieldSuffix string

	switch f.FieldFunction {
	case FilterFuncLower:
		fieldPrefix = "LOWER("
		fieldSuffix = ")"
	}

	return fieldPrefix + `t."` + f.Field + `"` + fieldSuffix + ` ` + f.Operation + ` $` + strconv.Itoa(index)
}

// Init is responsible to initialize all repositories
func Init(database *sql.DB) {
	db = database

	FeedbackRepo = FeedbackRepositorium{db: database}
	VisitorRepo = VisitorRepositorium{db: database}
	RatingRepo = RatingRepositorium{db: database}
}

// StartTransaction initiates a database transaction
func StartTransaction(ctx context.Context) (*sql.Tx, error) {
	return db.BeginTx(ctx, nil)
}

// SortOpts provides an SQL valid ORDER BY
func (s ListOpts) SortOpts(validateField func(string) bool) string {
	var sort []string
	for i := range s.Sort {
		var order string

		if !validateField(s.Sort[i].Field) {
			continue
		}

		if s.Sort[i].Ascending {
			order = "ASC"
		} else {
			order = "DESC"
		}
		sort = append(sort, `t."`+s.Sort[i].Field+`" `+order)
	}

	if len(sort) != 0 {
		return " ORDER BY " + strings.Join(sort, ", ")
	}

	return ""
}

// FeedbackRepository encapsulates operations that may be performed on the entity Feedback
type FeedbackRepository interface {
	// Insert performs an SQL insert for Feedback record and update instance with inserted id.
	Insert(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error
	// InsertWithRel performs an SQL insert for Feedback record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.
	InsertWithRel(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error

	// Get returns a single Feedback from database by primary key
	Get(ctx context.Context, id string) (*Feedback, error)
	// GetWithRel returns a single Feedback from database by primary key; loads related entities
	GetWithRel(ctx context.Context, id string) (*Feedback, error)

	// List returns a slice containing Feedback records
	List(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Feedback, error)
	// ListWithRel returns a slice containing Feedback records; will also load related entities.
	ListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Feedback, error)

	// Count returns a count of a query containing Feedback records
	Count(ctx context.Context, opts *ListOpts, filters ...*Filter) (int64, error)

	// Select returns a slice containing Feedback records according to a custom SQL condition
	Select(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Feedback, error)
	// SelectWithRel returns a slice containing Feedback records according to a custom SQL condition; will also load related entities.
	SelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Feedback, error)

	// Update Will execute an SQLUpdate Statement for Feedback in the database. Prefer using Save instead of Update directly.
	Update(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error
	// UpdateWithRel Will execute an SQLUpdate Statement for Feedback in the database; including related entities. Prefer using Save instead of Update directly.
	UpdateWithRel(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error
	// DeleteMany deletes many Feedback records from database using filter
	DeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error
	// Delete deletes a Feedback record from database and sets id to nil
	Delete(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error

	// Merge performs an SQL merge for Feedback record.
	Merge(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error
	// Save either inserts or updates a Feedback record based on whether or not id is nil
	Save(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error
	// SaveWithRel either inserts or updates a Feedback record based on whether or not id is nil; will also save related entities
	SaveWithRel(ctx context.Context, entity *Feedback, tx *sql.Tx, autocommit bool) error
	// LoadVisitor is a helper function to load related Visitor entities (many-one relationship)
	LoadVisitor(ctx context.Context, entities ...*Feedback) error
}

// FeedbackRepositorium implements FeedbackRepository
type FeedbackRepositorium struct {
	db *sql.DB
}

// VisitorRepository encapsulates operations that may be performed on the entity Visitor
type VisitorRepository interface {
	// Insert performs an SQL insert for Visitor record and update instance with inserted id.
	Insert(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error
	// InsertWithRel performs an SQL insert for Visitor record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.
	InsertWithRel(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error

	// Get returns a single Visitor from database by primary key
	Get(ctx context.Context, id string) (*Visitor, error)
	// GetWithRel returns a single Visitor from database by primary key; loads related entities
	GetWithRel(ctx context.Context, id string) (*Visitor, error)

	// List returns a slice containing Visitor records
	List(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Visitor, error)
	// ListWithRel returns a slice containing Visitor records; will also load related entities.
	ListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Visitor, error)

	// Count returns a count of a query containing Visitor records
	Count(ctx context.Context, opts *ListOpts, filters ...*Filter) (int64, error)

	// Select returns a slice containing Visitor records according to a custom SQL condition
	Select(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Visitor, error)
	// SelectWithRel returns a slice containing Visitor records according to a custom SQL condition; will also load related entities.
	SelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Visitor, error)

	// Update Will execute an SQLUpdate Statement for Visitor in the database. Prefer using Save instead of Update directly.
	Update(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error
	// UpdateWithRel Will execute an SQLUpdate Statement for Visitor in the database; including related entities. Prefer using Save instead of Update directly.
	UpdateWithRel(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error
	// DeleteMany deletes many Visitor records from database using filter
	DeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error
	// Delete deletes a Visitor record from database and sets id to nil
	Delete(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error

	// Merge performs an SQL merge for Visitor record.
	Merge(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error
	// Save either inserts or updates a Visitor record based on whether or not id is nil
	Save(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error
	// SaveWithRel either inserts or updates a Visitor record based on whether or not id is nil; will also save related entities
	SaveWithRel(ctx context.Context, entity *Visitor, tx *sql.Tx, autocommit bool) error
	// LoadFeedbacks is a helper function to load related Feedbacks entities (one-many relationship)
	LoadFeedbacks(ctx context.Context, entities ...*Visitor) error
}

// VisitorRepositorium implements VisitorRepository
type VisitorRepositorium struct {
	db *sql.DB
}

// RatingRepository encapsulates operations that may be performed on the entity Rating
type RatingRepository interface {
	// Insert performs an SQL insert for Rating record and update instance with inserted id.
	Insert(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error
	// InsertWithRel performs an SQL insert for Rating record and update instance with inserted id; including related entities. Prefer using Save instead of Insert directly.
	InsertWithRel(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error

	// Get returns a single Rating from database by primary key
	Get(ctx context.Context, id string) (*Rating, error)
	// GetWithRel returns a single Rating from database by primary key; loads related entities
	GetWithRel(ctx context.Context, id string) (*Rating, error)

	// List returns a slice containing Rating records
	List(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Rating, error)
	// ListWithRel returns a slice containing Rating records; will also load related entities.
	ListWithRel(ctx context.Context, opts *ListOpts, filters ...*Filter) ([]*Rating, error)

	// Count returns a count of a query containing Rating records
	Count(ctx context.Context, opts *ListOpts, filters ...*Filter) (int64, error)

	// Select returns a slice containing Rating records according to a custom SQL condition
	Select(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Rating, error)
	// SelectWithRel returns a slice containing Rating records according to a custom SQL condition; will also load related entities.
	SelectWithRel(ctx context.Context, opts *ListOpts, condition string, values ...interface{}) ([]*Rating, error)

	// Update Will execute an SQLUpdate Statement for Rating in the database. Prefer using Save instead of Update directly.
	Update(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error
	// UpdateWithRel Will execute an SQLUpdate Statement for Rating in the database; including related entities. Prefer using Save instead of Update directly.
	UpdateWithRel(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error
	// DeleteMany deletes many Rating records from database using filter
	DeleteMany(ctx context.Context, tx *sql.Tx, autocommit bool, filters ...*Filter) error
	// Delete deletes a Rating record from database and sets id to nil
	Delete(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error

	// Merge performs an SQL merge for Rating record.
	Merge(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error
	// Save either inserts or updates a Rating record based on whether or not id is nil
	Save(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error
	// SaveWithRel either inserts or updates a Rating record based on whether or not id is nil; will also save related entities
	SaveWithRel(ctx context.Context, entity *Rating, tx *sql.Tx, autocommit bool) error
}

// RatingRepositorium implements RatingRepository
type RatingRepositorium struct {
	db *sql.DB
}

// QueryAddIN adds IN condition to query
func QueryAddIN(segments []string, values []interface{}, index *int, fieldname string, val interface{}, not bool) ([]string, []interface{}, error) {
	var subsegments []string

	if data, ok := val.([]bool); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]byte); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]complex64); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]complex128); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]float32); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]float64); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]int); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]int8); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]int16); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]int32); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]int64); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]rune); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]string); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]uint); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]uint8); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]uint16); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]uint32); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]uint64); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else if data, ok := val.([]uintptr); ok {
		for d := range data {
			*index++
			subsegments = append(subsegments, "$"+strconv.Itoa(*index))
			values = append(values, data[d])
		}
	} else {
		return nil, nil, moderrors.InFilterValueUnknownError
	}

	if len(subsegments) == 0 {
		return nil, nil, moderrors.InFilterValueEmptyError
	}

	condition := " IN"
	if not {
		condition = " NOT" + condition
	}

	segments = append(segments, fieldname+condition+" ("+strings.Join(subsegments, ",")+")")
	return segments, values, nil
}
